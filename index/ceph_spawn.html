<hr>
<h2 id="title-ceph-spawn"><a href="#title-ceph-spawn" class="headerlink" title="title: ceph spawn"></a>title: ceph spawn</h2><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从ceph P版本开始，引入了一个spawn组件，用来实现协程相关的功能。这个组件实际上是复制于boost::asio，而boost打算在未来抛弃spawn这部分代码，换成其他实现形式，因此ceph不得不把这部分代码备份到自己的项目中。</p>
<h1 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h1><p>spawn方法用于将一个用户自定义函数封装成一个协程来运行</p>
<pre><code>template &lt;typename Function, typename ExecutionContext, typename StackAllocator&gt;
auto spawn(ExecutionContext&amp; ctx, Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)
  -&gt; typename std::enable_if&lt;std::is_convertible&lt;
       ExecutionContext&amp;, detail::net::execution_context&amp;&gt;::value &amp;&amp;
       detail::is_stack_allocator&lt;typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type
{
  spawn(ctx.get_executor(),
      std::forward&lt;Function&gt;(function),
      std::forward&lt;StackAllocator&gt;(salloc));
}
</code></pre>
<p>上述方法接收3个参数：ExecutionContext、Function、StackAllocator；<br>其中，ExecutionContext可以是一个boost::asio::io_context实例，作为调度上下文；<br>StackAllocator用于申请内存作为协程栈，它决定了栈的位置和大小, StackAllocator可以不指定，默认为boost::context::default_stack<br>上述方法从ExecutionContext中取得Executor（调度队列），再传递给spawn的另一重载形式</p>
<pre><code>template &lt;typename Function, typename Executor, typename StackAllocator&gt;
auto spawn(const Executor&amp; ex, Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)
  -&gt; typename std::enable_if&lt;detail::net::is_executor&lt;Executor&gt;::value &amp;&amp;
       detail::is_stack_allocator&lt;typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type
{
  spawn(detail::net::strand&lt;Executor&gt;(ex),
      std::forward&lt;Function&gt;(function),
      std::forward&lt;StackAllocator&gt;(salloc));
}
</code></pre>
<p>上述重载形式会将Executor进一步封装成strand<Executor>传给下一个重载形式，strand<Executor>本质上也是一种调度队列，它与常规的Executor不同之处在于，常规的Executor支持多线程并发取任务执行，而strand<Executor>只支持顺序执行，不存在多任务并发的情况，适合任务间有顺序要求的场景。<br>这里使用strand<Executor>是为了在任务投递到相同队列的情况下，确保协程任务的后半段不会先于前半段执行，并且创建的子任务按顺序执行（减少资源竞争）。</p>
<pre><code>template &lt;typename Function, typename Executor, typename StackAllocator&gt;
auto spawn(const detail::net::strand&lt;Executor&gt;&amp; ex,
           Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)
  -&gt; typename std::enable_if&lt;detail::is_stack_allocator&lt;
       typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type
{
  spawn(bind_executor(ex, &amp;detail::default_spawn_handler),
      std::forward&lt;Function&gt;(function),
      std::forward&lt;StackAllocator&gt;(salloc));
}
</code></pre>
<p>上述重载形式将strand<Executor> 绑定到一个default_spawn_handler上再传递到下一重载形式，default_spawn_handler是个空函数对象，仅作占位用途。<br>这里为什么选择将两个参数绑定到一起，而不是分别传递，可能是为了减少函数签名的复杂度。</p>
<pre><code>template &lt;typename Handler, typename Function, typename StackAllocator&gt;
auto spawn(Handler&amp;&amp; handler, Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)
  -&gt; typename std::enable_if&lt;!detail::net::is_executor&lt;typename std::decay&lt;Handler&gt;::type&gt;::value &amp;&amp;
       !std::is_convertible&lt;Handler&amp;, detail::net::execution_context&amp;&gt;::value &amp;&amp;
       !detail::is_stack_allocator&lt;typename std::decay&lt;Function&gt;::type&gt;::value &amp;&amp;
       detail::is_stack_allocator&lt;typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type
{
  using handler_type = typename std::decay&lt;Handler&gt;::type;
  using function_type = typename std::decay&lt;Function&gt;::type;

  auto ex = detail::net::get_associated_executor(handler);
  auto a = detail::net::get_associated_allocator(handler);

  detail::spawn_helper&lt;handler_type, function_type, StackAllocator&gt; helper;
  helper.data_ = std::make_shared&lt;
      detail::spawn_data&lt;handler_type, function_type, StackAllocator&gt; &gt;(
        std::forward&lt;Handler&gt;(handler), true,
        std::forward&lt;Function&gt;(function),
        std::forward&lt;StackAllocator&gt;(salloc));

  ex.dispatch(helper, a);
}
</code></pre>
<p>最终spawn会调用到首参数为Handler的重载形式，这个重载形式真正实现了spawn的逻辑。<br>它先从Handler上取得绑定的调度队列和内存分配器，加上Function、StackAllocator和Handler自身构建一个spawn_data。这个spawn_data就代表了一个协程的完整信息。<br>spawn_helper是一个可调用对象，作为协程启动器来使用，它将spawn_data包含进去，在执行时会依据spawn_data提供的信息，负责构建并运行协程。<br>这里将spawn_helper作为一个任务投递到队列中，由后台线程调度执行。</p>
<h1 id="spawn-helper"><a href="#spawn-helper" class="headerlink" title="spawn_helper"></a>spawn_helper</h1><p>spawn_helper的具体实现如下：</p>
<pre><code>template &lt;typename Handler, typename Function, typename StackAllocator&gt;
struct spawn_helper
{
  void operator()()
  {
    callee_.reset(new continuation_context());
    callee_-&gt;context_ = boost::context::callcc(
        std::allocator_arg, std::move(data_-&gt;salloc_),
        [this] (boost::context::continuation&amp;&amp; c)
        {
          std::shared_ptr&lt;spawn_data&lt;Handler, Function, StackAllocator&gt; &gt; data = data_;
          data-&gt;caller_.context_ = std::move(c);
          const basic_yield_context&lt;Handler&gt; yh(callee_, data-&gt;caller_, data-&gt;handler_);
          try
          {
            (data-&gt;function_)(yh);
            if (data-&gt;call_handler_)
            {
              (data-&gt;handler_)();
            }
          }
          catch (const boost::context::detail::forced_unwind&amp; e)
          {
            throw; // must allow forced_unwind to propagate
          }
          catch (...)
          {
            auto callee = yh.callee_.lock();
            if (callee)
              callee-&gt;eptr_ = std::current_exception();
          }
          boost::context::continuation caller = std::move(data-&gt;caller_.context_);
          data.reset();
          return caller;
        });
    if (callee_-&gt;eptr_)
      std::rethrow_exception(std::move(callee_-&gt;eptr_));
  }

  std::shared_ptr&lt;continuation_context&gt; callee_;
  std::shared_ptr&lt;spawn_data&lt;Handler, Function, StackAllocator&gt; &gt; data_;
};
</code></pre>
<p>spawn_helper使用boost::context::callcc创建协程栈，并将一个lambda函数放在栈上运行。<br>可以看到在spawn_helper的lambda函数中，它先将spawn_data的共享指针缓存到协程栈上，避免协程信息丢失。（spawn_helper在运行完协程第一段后就会销毁掉，不能再依赖它维护spawn_data）。<br>然后基于现有信息创建了一个basic_yield_context传递给function，这个yield_context会贯穿整个协程流程，作为协程切换的句柄。<br>handler放在function之后执行，用于处理一些用户自定义的善后工作，也可以什么也不做。<br>可以注意到协程运行过程中抛出的异常，不会直接在协程上下文中处理，而是封装成一个exception_ptr，在协程调度完毕后，由协程的调用者来抛出异常。<br>spawn_helper只会运行协程的第一段逻辑，在协程第一次阻塞后，spawn_helper就会从boost::context::callcc的调用逻辑中返回。由boost::context::callcc创建的协程句柄会保存在spawn_helper的callee_变量上。<br>callee_变量被lambda函数捕获，并将其记录到yield_context上，加上lambda函数的入参构建的caller_变量，此时调用者和协程的上下文都能被yield_context索引到。</p>
<h1 id="spawn-data"><a href="#spawn-data" class="headerlink" title="spawn_data"></a>spawn_data</h1><p>spawn_data的定义如下：</p>
<pre><code>template &lt;typename Handler, typename Function, typename StackAllocator&gt;
struct spawn_data
{
  Handler handler_;
  bool call_handler_;
  Function function_;
  StackAllocator salloc_;
  continuation_context caller_;
};
</code></pre>
<p>Hanlder、Function、StackAllocator这些协程要素都由spawn_data维护生存期。<br>caller_ 对应调用者上下文，它的生存期也由spawn_data维护，</p>
<h1 id="basic-yield-context"><a href="#basic-yield-context" class="headerlink" title="basic_yield_context"></a>basic_yield_context</h1><p>basic_yield_context的定义如下：</p>
<pre><code>template &lt;typename Handler&gt;
class basic_yield_context
{
public:
  std::weak_ptr&lt;detail::continuation_context&gt; callee_;
  detail::continuation_context&amp; caller_;
  Handler handler_;
  boost::system::error_code* ec_;
};
</code></pre>
<p>callee_对应协程上下文；<br>caller_对应调用者上下文；<br>handler_放在basic_yield_context中主要是为了方便取得executor 和 allocator;<br>ec_用于记录错误码，外部流程可以在唤醒协程前，将自己收集到的错误记录于此通知协程，以便于中止协程。</p>
<h1 id="async-completion"><a href="#async-completion" class="headerlink" title="async_completion"></a>async_completion</h1><p>STL 提供了promise 和 future 来实现多线程间的消息通知。<br>而为了能兼容更宽泛的消息通知形式（比如协程），boost提供了async_completion模板来构造消息的接收方和发送方。</p>
<pre><code>template &lt;typename CompletionToken, BOOST_ASIO_COMPLETION_SIGNATURE Signature&gt;
struct async_completion {
  /// The real handler type to be used for the asynchronous operation.
  typedef typename boost::asio::async_result&lt;
    typename decay&lt;CompletionToken&gt;::type,
      Signature&gt;::completion_handler_type completion_handler_type;

  explicit async_completion(typename decay&lt;CompletionToken&gt;::type&amp; token)
    : completion_handler(token),
      result(completion_handler)
  {
  }

  /// A copy of, or reference to, a real handler object.
  completion_handler_type completion_handler;

  /// The result of the asynchronous operation&#39;s initiating function.
  async_result&lt;typename decay&lt;CompletionToken&gt;::type, Signature&gt; result;
};
</code></pre>
<p>在这里，使用result作为消息的接收方，对应future；<br>使用completion_handler作为消息的发送方，对应promise。</p>
<p>async_completion有2个模板参数：CompletionToken 和 Signature。<br>CompletionToken 包含了初始化所需的必要信息，它决定了async_completion的实例化类型；<br>Signature 是函数签名，对应了completion_handler 的调用形式，决定了消息的定义结构。</p>
<p>async_completion 初始化流程如下：</p>
<ol>
<li>根据CompletionToken类型找到对应的async_result模板, 决定result的类型；</li>
<li>从async_result模板得知对应的 completion_handler 的类型；</li>
<li>使用CompletionToken 初始化completion_handler；</li>
<li>使用completion_handler 初始化result；</li>
</ol>
<h1 id="coro-async-result、coro-handler"><a href="#coro-async-result、coro-handler" class="headerlink" title="coro_async_result、coro_handler"></a>coro_async_result、coro_handler</h1><p>下面以yield_context作为CompletionToken，举例说明async_completion的效果：</p>
<pre><code>template &lt;typename Handler&gt;
void my_func(basic_yield_context&lt;Handler&gt; yield) {
  // 基于yield_context构建异步上下文completion
  boost::asio::async_completion&lt;
    basic_yield_context&lt;Handler&gt;, void()
  &gt; completion(yield);

  // 从异步上下文completion中取出completion_handler传递给异步流程
  auto async_thread = thread(
    [completion_handler=completion.completion_handler]{
      sleep(5);
      // 异步流程将completion_handler作为回调函数，投递到调度队列去重新运行协程
      auto executor = boost::asio::get_associated_executor(completion_handler);
      auto allocator = boost::asio::get_associated_allocator(completion_handler);
      executor.post(move(completion_handler), allocator);
    });
  async_thread.detach();

  // 当前流程使用completion.result进行等待，由completion_handler唤醒
  completion.result.get();
}
</code></pre>
<p>当yield_context作为CompletionToken时，找到的async_result模板如下：</p>
<pre><code>template &lt;typename Handler, typename ReturnType&gt;
class SPAWN_NET_NAMESPACE::async_result&lt;spawn::basic_yield_context&lt;Handler&gt;, ReturnType()&gt;
  : public spawn::detail::coro_async_result&lt;Handler, void&gt;
{
public:
  explicit async_result(
    typename spawn::detail::coro_async_result&lt;Handler,
      void&gt;::completion_handler_type&amp; h)
    : spawn::detail::coro_async_result&lt;Handler, void&gt;(h)
  {
  }
};

template &lt;typename Handler&gt;
class coro_async_result&lt;Handler, void&gt;
{
public:
  using completion_handler_type = coro_handler&lt;Handler, void&gt;;
  using return_type = void;

  explicit coro_async_result(completion_handler_type&amp; h)
    : handler_(h),
      caller_(h.caller_),
      ready_(2)
  {
    h.ready_ = &amp;ready_;
    out_ec_ = h.ec_;
    if (!out_ec_) h.ec_ = &amp;ec_;
  }

  void get()
  {
    // Must not hold shared_ptr while suspended.
    handler_.callee_.reset();

    if (--ready_ != 0)
      caller_.resume(); // suspend caller
    if (!out_ec_ &amp;&amp; ec_) throw boost::system::system_error(ec_);
  }

private:
  completion_handler_type&amp; handler_;
  continuation_context&amp; caller_;
  std::atomic&lt;long&gt; ready_;
  boost::system::error_code* out_ec_;
  boost::system::error_code ec_;
};
</code></pre>
<p>可见 yield_context 将async_result模板实例化成一个coro_async_result类型。<br>coro_async_result 初始化时会将自己的ready_、ec_成员共享给completion_handler，而completion_handler把自己的caller_成员共享给coro_async_result。<br>当我们调用coro_async_result的get方法时，它会先将handler_的callee_清空，所以必须在调用前，把completion_handler转移到其他地方。<br>然后它会使用ready_的值来判断get 和 completion_handler的先后顺序，ready_初始值为2，get 和 completion_handler都会令它的值减一，最终归0。<br>如果是get先调用，那么ready_会下降到1，此时需要通过caller_.resume方法，切回调用者上下文，阻塞协程逻辑，等待下一步唤醒；如果是completion_handler先执行，那么那么ready_会下降到0，此时不需要切换协程，继续运行当前流程即可。</p>
<p>coro_async_result 对应的completion_handler类型为coro_handler：</p>
<pre><code>template &lt;typename Handler&gt;
class coro_handler&lt;Handler, void&gt;
{
public:
  coro_handler(basic_yield_context&lt;Handler&gt; ctx)
    : callee_(ctx.callee_.lock()),
      caller_(ctx.caller_),
      handler_(ctx.handler_),
      ready_(0),
      ec_(ctx.ec_)
  {
  }

  void operator()()
  {
    *ec_ = boost::system::error_code();
    if (--*ready_ == 0)
      callee_-&gt;resume();
  }

  void operator()(boost::system::error_code ec)
  {
    *ec_ = ec;
    if (--*ready_ == 0)
      callee_-&gt;resume();
  }

//private:
  std::shared_ptr&lt;continuation_context&gt; callee_;
  continuation_context&amp; caller_;
  Handler handler_;
  std::atomic&lt;long&gt;* ready_;
  boost::system::error_code* ec_;
};
</code></pre>
<p>coro_handler初始化时，从basic_yield_context复制了一份callee_的强引用，确保callee_不会在回调完成前析构掉。这也是为何basic_yield_context只保留callee_弱引用的原因，因为协程总会在切出前把callee_的强引用复制给一个completion_handler，basic_yield_context只需发挥一个桥梁的作用，将callee_的引用过渡给新的流程。<br>coro_handler还需要从basic_yield_context取得caller_引用记录下来，待会传递给coro_async_result使用。<br>coro_handler被调用时，它会判断ready_值，当ready_下降到0时，意味者result.get已被调用，那么执行callee_-&gt;resume方法，跳转到协程上下文继续运行；如果ready_不为0，意味着协程还没有陷入阻塞，不必唤醒，什么也不做。</p>
<p>async_result 和 completion_handler 是成对的，两者都是不可重入类型，只能调用一次，能在一定程度上容忍乱序执行，但是还存在一个缺陷，复现过程如下：<br>（1）线程1：执行result.get，–*ready_ &#x3D;&#x3D; 1；<br>（2）线程2：执行completion_handler，–*ready_ &#x3D;&#x3D; 0；<br>（3）线程2：执行callee_-&gt;resume()，但是此时线程1尚未让出协程执行权，触发断言错误崩溃<br>（4）线程1：执行caller_.resume()</p>
<p>因此最好使用strand或其他方法来确保completion_handler 和 result.get 不会同时执行。</p>
<h1 id="continuation-context"><a href="#continuation-context" class="headerlink" title="continuation_context"></a>continuation_context</h1><p>上面提到的callee 和 caller 都属于continuation_context类型，它们分别代表协程上下文和调用者上下文。</p>
<pre><code>class continuation_context
{
public:
  boost::context::continuation context_;
  std::exception_ptr eptr_;

  void resume()
  {
    context_ = context_.resume();

    if (eptr_)
      std::rethrow_exception(std::move(eptr_));
  }
};
</code></pre>
<p>这个结构体比较简单，它是对boost::context::continuation的封装，主要是增加了一个exception_ptr成员，用来保存协程运行过程中抛出的异常，等到流程返回调用者上下文后，再将异常抛出，避免在协程栈上做回溯动作，造成不可控制的后果（协程目前只处理了forced_unwind类型的异常，其他类型的异常可能会一直向上回溯，突破栈的界限）。<br>通过调用continuation::resume函数来跳转到目标上下文运行，当context_对应协程上下文时，是切入协程；当context_对应调用者上下文时，是切出协程。<br>在resume运行期间context_会被置为空；仅当resume完毕后才会返回一个新的continuation赋予context_，达到更新上下文地址的目的，同时也能在一定程度上避免多线程运行在同一个上下文。</p>
<h1 id="continuation"><a href="#continuation" class="headerlink" title="continuation"></a>continuation</h1><p>continuation的定义也很简单，它是对fcontext_t的封装：</p>
<pre><code>class continuation {
private:
  detail::fcontext_t  fctx_{ nullptr };

  continuation( detail::fcontext_t fctx) noexcept :
      fctx_{ fctx } {
  }

  continuation resume() &amp; {
      return std::move( * this).resume();
  }

  continuation resume() &amp;&amp; {
      BOOST_ASSERT( nullptr != fctx_);
      return { detail::jump_fcontext(
                  std::exchange( fctx_, nullptr),
                  nullptr).fctx };
  }
}
</code></pre>
<p>这里fcontext_t是一个void*类型，它对应目标上下文的栈顶地址，continuation::resume就是通过jump_fcontext切换上下文。<br>可以注意到在将fctx_传给jump_fcontext后，fctx_就被交换为空值；在jump_fcontext返回新的fctx后，才重构一个新的continuation输出，以此来转移协程执行权。</p>
<h1 id="jump-fcontext"><a href="#jump-fcontext" class="headerlink" title="jump_fcontext"></a>jump_fcontext</h1><p>jump_fcontext的函数签名如下：</p>
<pre><code>typedef void*   fcontext_t;

struct transfer_t {
    fcontext_t  fctx;
    void    *   data;
};

transfer_t jump_fcontext( fcontext_t const to, void * vp);
</code></pre>
<p>jump_fcontext是一个用汇编代码实现的函数，它的效果是切换到目标上下文继续运行，具体步骤如下：</p>
<ol>
<li>保存当前的寄存器值到栈上（入栈）</li>
<li>复制SP寄存器的值到AX寄存器上（准备返回值1）</li>
<li>用参数to重置SP寄存器的值（切栈）</li>
<li>从新的栈上还原寄存器值 （出栈）</li>
<li>将参数vp的值保存到DX寄存器上 （准备返回值2）</li>
<li>复制AX寄存器的值（源栈顶地址）到DI寄存器上 （准备调用参数1，后面介绍）</li>
<li>从新的栈上取出返回地址，使用jmp指令跳转到目标流程继续运行 （函数返回）</li>
</ol>
<p>这个函数的效果可以分2个视角来看待：</p>
<ol>
<li>线程的视角：jump_fcontext将当前线程的栈切换为参数to给定的栈，运行地址也切换为新的，它把原来的栈顶地址和参数vp通过返回值的形式传输到新的上下文，这样就实现了2个上下文间的消息传递，并且新的上下文拥有源栈顶地址可以随时跳转回去。<br><img src="/ceph_spawn/jump_fcontext.png"></li>
<li>函数的视角：jump_fcontext似乎和普通的函数没什么区别，它可以用于唤醒参数to代表的目标上下文继续运行，并将参数vp作为消息发送过去，然后当前流程会一直阻塞在jump_fcontext这里，直至收到消息被唤醒，此时jump_fcontext会返回发送方的上下文地址fctx以及消息data。<br><img src="/ceph_spawn/jump_fcontext2.png"></li>
</ol>
<h1 id="callcc"><a href="#callcc" class="headerlink" title="callcc"></a>callcc</h1><p>boost::context::callcc 用于将给定的函数封装到协程中。</p>
<pre><code>template&lt; typename StackAlloc, typename Fn &gt;
continuation
callcc( std::allocator_arg_t, StackAlloc &amp;&amp; salloc, Fn &amp;&amp; fn) {
    using Record = detail::record&lt; continuation, StackAlloc, Fn &gt;;
    return continuation{
                detail::create_context1&lt; Record &gt;(
                        std::forward&lt; StackAlloc &gt;( salloc), std::forward&lt; Fn &gt;( fn) ) }.resume();
}
</code></pre>
<p>这个函数主要做了几件事：</p>
<ol>
<li>使用create_context1创建协程，返回协程栈顶地址</li>
<li>用协程栈顶地址初始化一个continuation</li>
<li>调用continuation的resume方法运行协程</li>
<li>返回运行后的新continuation（封装了新的协程栈顶地址）</li>
</ol>
<h1 id="create-context1"><a href="#create-context1" class="headerlink" title="create_context1"></a>create_context1</h1><p>create_context1函数的定义如下：</p>
<pre><code>template&lt; typename Record, typename StackAlloc, typename Fn &gt;
fcontext_t create_context1( StackAlloc &amp;&amp; salloc, Fn &amp;&amp; fn) {
  auto sctx = salloc.allocate();
  // reserve space for control structure
  void * storage = reinterpret_cast&lt; void * &gt;(
      ( reinterpret_cast&lt; uintptr_t &gt;( sctx.sp) - static_cast&lt; uintptr_t &gt;( sizeof( Record) ) ) &amp; ~static_cast&lt; uintptr_t &gt;( 0xff) );
  // placment new for control structure on context stack
  Record * record = new ( storage) Record{
          sctx, std::forward&lt; StackAlloc &gt;( salloc), std::forward&lt; Fn &gt;( fn) };
  // 64byte gab between control structure and stack top
  // should be 16byte aligned
  void * stack_top = reinterpret_cast&lt; void * &gt;(
          reinterpret_cast&lt; uintptr_t &gt;( storage) - static_cast&lt; uintptr_t &gt;( 64) );
  void * stack_bottom = reinterpret_cast&lt; void * &gt;(
          reinterpret_cast&lt; uintptr_t &gt;( sctx.sp) - static_cast&lt; uintptr_t &gt;( sctx.size) );
  // create fast-context
  const std::size_t size = reinterpret_cast&lt; uintptr_t &gt;( stack_top) - reinterpret_cast&lt; uintptr_t &gt;( stack_bottom);
  const fcontext_t fctx = make_fcontext( stack_top, size, &amp; context_entry&lt; Record &gt;);
  BOOST_ASSERT( nullptr != fctx);
  // transfer control structure to context-stack
  return jump_fcontext( fctx, record).fctx;
}
</code></pre>
<p>它的步骤可以简要描述为：</p>
<ol>
<li>使用参数StackAlloc分配了一块内存，使用内存的尾部作为栈顶（栈向低地址延伸）</li>
<li>在栈顶创建一个record结构，用来保存协程信息，比如栈地址、栈大小、栈分配器、用户函数等</li>
<li>使用make_fcontext在新的栈顶上（record的上面）伪造一个栈帧，将context_entry函数地址作为返回地址保存在栈帧中（实际的实现会更复杂一些）<br><img src="/ceph_spawn/3.png"></li>
<li>使用jump_fcontext跳转到伪造的栈帧上，并将record地址作为消息传递过去</li>
<li>jump_fcontext函数退栈，访问到返回地址时，变成对context_entry函数的调用（这里利用到了jump_fcontext时保存到DI寄存器上的源栈顶地址，作为函数的第一参数，第二参数则继承于jump_fcontext的第二参数vp），而不是返回到上一级（实际上也不存在上一级）</li>
<li>进入context_entry函数后，先从参数取得record地址缓存到栈上，再通过jump_fcontext跳转回create_context1的上下文，这样两边的跳转通道都建立好了</li>
<li>create_context1函数返回最新的目标上下文地址，也就是context_entry函数的栈顶地址</li>
</ol>
<h1 id="context-entry"><a href="#context-entry" class="headerlink" title="context_entry"></a>context_entry</h1><p>context_entry类似于协程的main函数，下面是它的定义：</p>
<pre><code>template&lt; typename Rec &gt;
void context_entry( transfer_t t) noexcept {
    // transfer control structure to the context-stack
    Rec * rec = static_cast&lt; Rec * &gt;( t.data);
    BOOST_ASSERT( nullptr != t.fctx);
    BOOST_ASSERT( nullptr != rec);
    try {
        // jump back to `create_context()`
        t = jump_fcontext( t.fctx, nullptr);
        // start executing
        t.fctx = rec-&gt;run( t.fctx);
    } catch ( forced_unwind const&amp; ex) {
        t = { ex.fctx, nullptr };
#ifndef BOOST_ASSERT_IS_VOID
        const_cast&lt; forced_unwind &amp; &gt;( ex).caught = true;
#endif
    }
    BOOST_ASSERT( nullptr != t.fctx);
    // destroy context-stack of `this`context on next context
    ontop_fcontext( t.fctx, rec, context_exit&lt; Rec &gt;);
    BOOST_ASSERT_MSG( false, &quot;context already terminated&quot;);
}
</code></pre>
<p>其中t.data就对应之前提到的record地址，t.fctx则是调用者的栈顶地址。<br>context_entry在运行record::run前使用jump_fcontext返回了原本的上下文，告知调用者进入协程的通道已准备就绪，下次通过jump_fcontext进入就无需携带任何消息了。<br>record::run函数的实现很简单，就只是将调用者的栈顶地址封装成一个continuation，作为参数传递给业务函数fn_并运行，业务函数需要切出上下文时就会用到这个continuation。这里的fn_实际上就对应spawn_helper处的lambda函数。</p>
<pre><code>fcontext_t record::run( fcontext_t fctx) {
  continuation c{ fctx };
  // invoke context-function
  c = std::invoke( fn_, std::move( c) )
  return std::exchange( c.fctx_, nullptr);
}
</code></pre>
<p>context_entry用try catch 包围了record::run函数，用于捕获forced_unwind类型的异常，context_entry会从该异常中取出新的调用者栈顶地址，而不是从record::run函数的返回值获取。这在需要提前终止协程的情况下很有用。<br>在流程的最后（无论是record::run正常返回，还是捕获到异常提前退出），通过ontop_fcontext函数返回调用者上下文，并触发context_exit函数清理协程栈。</p>
<h1 id="ontop-fcontext"><a href="#ontop-fcontext" class="headerlink" title="ontop_fcontext"></a>ontop_fcontext</h1><p>ontop_fcontext函数的声明如下：</p>
<pre><code>transfer_t ontop_fcontext( fcontext_t const to, void * vp, transfer_t (* fn)( transfer_t) );
</code></pre>
<p>ontop_fcontext函数也是一个用汇编代码实现的函数，它的效果和 jump_fcontext类似，都会切换到目标上下文，但是jump_fcontext在最后是从栈上取出返回地址跳转，而ontop_fcontext则是使用第三个参数（函数指针）作为跳转地址，前两个参数作为函数传参，待目标函数执行完成后，才从当前栈上取出地址返回，相当于ontop_fcontext不光完成了上下文切换，还在切换后多执行了一个函数，这个函数的返回值限定为fcontext_t，必须和jump_fcontext 保持一致，这样才能顺利衔接。</p>
<h1 id="协程的销毁"><a href="#协程的销毁" class="headerlink" title="协程的销毁"></a>协程的销毁</h1><p>销毁协程采用context_exit函数，它调用给定的record实例的deallocate来完成工作，最后通过返回空地址来告诉调用者协程运行完毕。</p>
<pre><code>template&lt; typename Rec &gt;
transfer_t context_exit( transfer_t t) noexcept {
    Rec * rec = static_cast&lt; Rec * &gt;( t.data);
    // destroy context stack
    rec-&gt;deallocate();
    return { nullptr, nullptr };
}
</code></pre>
<p>record::deallocate函数通过调用静态方法destroy，对record结构体进行析构，并调用栈分配器的方法摧毁整个协程栈。</p>
<pre><code>void record::deallocate() noexcept {
  destroy( this);
}

static void destroy( record * p) noexcept {
  typename std::decay&lt; StackAlloc &gt;::type salloc = std::move( p-&gt;salloc_);
  stack_context sctx = p-&gt;sctx_;
  // deallocate record
  p-&gt;~record();
  // destroy stack with stack allocator
  salloc.deallocate( sctx);
}
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上所述，协程的创建、切入、切出、销毁可以用下面一幅图来描述：<br><img src="/ceph_spawn/4.png"></p>
