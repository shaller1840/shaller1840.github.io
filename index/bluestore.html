<hr>
<h2 id="title-Bluestore存储结构"><a href="#title-Bluestore存储结构" class="headerlink" title="title: Bluestore存储结构"></a>title: Bluestore存储结构</h2><h2 id="物理段"><a href="#物理段" class="headerlink" title="物理段"></a>物理段</h2><p>物理段对应磁盘上的一段连续区域，使用“物理偏移量 + 长度”组成的二元组来表示它。物理段的偏移量和长度都是块大小对齐的。</p>
<pre><code>struct bluestore_pextent_t: public bluestore_interval_t&lt;uint64_t, uint32_t&gt; {};
</code></pre>
<h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p>由于磁盘分配器不一定能够分配出大段连续的物理区域，所以我们需要抽象出一个Blob结构，用于将申请到的多个不连续物理段映射为一个连续的逻辑区域。一个blob对应一个bluestore_blob_t结构体，它的基本属性如下：</p>
<pre><code>struct bluestore_blob_t {
    PExtentVector extents;  // blob包含的物理段
    uint32_t logical_length = 0;       // blob的逻辑长度
    uint32_t compressed_length = 0;   // blob压缩后的长度
    uint32_t flags = 0;  // 描述blob的一些额外特征
    uint16_t  unused = 0; // 用一个位图来表示blob各个部分的使用情况
    uint8_t csum_type = Checksummer::CSUM_NONE;    // 校验算法，如CRC32
    uint8_t csum_chunk_order = 0;   // 校验块长度 =  1&lt;&lt;block_order bytes
    bufferptr csum_data;     // 用于保存校验码
}
</code></pre>
<p>基于extents列表我们可以很容易推算出blob的每个逻辑部分对应的磁盘区域。<br>unused位图用于在写事务中，判断目标区域是否存在数据。如果没有数据，写事务可以直接覆写目标区域，否则需要先读取旧数据和当前数据合并后再写入。unused位图只有16位，意味着它最多将blob均匀划分成16份来统计各部分的使用情况，当blob的长度发生变化时，每个位代表的区域长度也会随之变化。<br>blob的校验码计算，是将blob按照csum_chunk_order表示的大小拆分成多个等长的块，分别计算出校验码后，再按顺序连接起来保存到csum_data中。</p>
<p>flags的可选值如下：</p>
<pre><code>LEGACY_FLAG_MUTABLE = 1,  // 表示blob可以被覆写和拆分
FLAG_COMPRESSED = 2,   // blob已经被压缩了，不可修改
FLAG_CSUM = 4,         // blob已经计算出校验码了
FLAG_HAS_UNUSED = 8,   // blob包含未被使用的部分
FLAG_SHARED = 16,      // blob被多个对象所共享，不可修改
</code></pre>
<p>其中LEGACY_FLAG_MUTABLE是个废弃的标志，它等价于（flags &amp;（FLAG_COMPRESSED | FLAG_SHARED））&#x3D;&#x3D; 0</p>
<h2 id="Extent"><a href="#Extent" class="headerlink" title="Extent"></a>Extent</h2><p>Blob只是作为磁盘分配器单次申请的逻辑单位，并不能表示对象的空间映射关系，所以还需要增加一个Extent结构来表示对象的一个逻辑段，记录到blob的映射关系。<br>同时磁盘分配器一次分配的逻辑长度可能会超过实际所需的长度（为了减少磁盘碎片化），使用Extent也能更精确地反映出对象实际使用的部分。<br>Extent的基本属性如下：</p>
<pre><code>struct Extent: public ExtentBase {
    uint32_t logical_offset = 0;
    uint32_t blob_offset = 0;
    uint32_t length = 0;
    BlobRef blob;
}
</code></pre>
<p>Extent的主要成员有4个，分别表示对象内的逻辑偏移量、相对于blob起始地址的偏移量、区段长度和所属的blob。<br><img src="/bluestore/2.png"></p>
<h2 id="ExtentMap"><a href="#ExtentMap" class="headerlink" title="ExtentMap"></a>ExtentMap</h2><p>同一个对象下的所有逻辑区段（Extent）组成一个ExtentMap。</p>
<pre><code>struct ExtentMap {
    typedef boost::intrusive::set&lt;Extent&gt; extent_map_t;
    extent_map_t extent_map;
    blob_map_t spanning_blob_map;
    vector&lt;Shard&gt; shards;
    bufferlist inline_bl;
};
</code></pre>
<p>spanning_blob_map用来记录被多个shard共享的blob，和常规的blob分开保存。<br>inline_bl用来缓存extent_map的编码结果，它的编码形式为：</p>
<pre><code>uint32_t blobs_num;
{
    uint64_t   blobid;
    uint64_t   gap;
    uint32_t   Extent::blob_offset
    uint32_t   Extent::length; 
    Blob       blob;
}
...
{
    uint64_t   blobid;
    uint64_t   gap;
    uint32_t   Extent::blob_offset
    uint32_t   Extent::length; 
    Blob       blob;
}
</code></pre>
<p>第一个字段blobs_num表示编码中含有多少个blob，<br>后面则是每个extent的编码，extent的编码从blobid开始，blobid分为两个部分，高位代表当前extent从属于的blob序号，低位则作为解码标志位，用于省略某些字段，优化编码格式<br>gap表示当前extent相对于前一个extent尾部的间隔，当前extent的logical_offset要结合gap和上一个extent的位置来计算，如果这是第一个extent，那么gap就是这个extent的logical_offset。<br>Blob并不总是编码在每个extent之后，如果多个extent共享一个blob，那么Blob只编码在相关的第一个extent后面（此时blob序号为0），后续的extent通过非零的blob序号来索引到相同的blob上。<br>解码标志位的可选值如下：</p>
<pre><code>BLOBID_FLAG_CONTIGUOUS: 表示当前gap为0，省略
BLOBID_FLAG_ZEROOFFSET：表示当前blob_offset为0，省略
BLOBID_FLAG_SAMELENGTH：表示length和前一个extent相同，省略
BLOBID_FLAG_SPANNING：表示当前extent从属的blob位于spanning_blob_map中
</code></pre>
<h2 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a>Shard</h2><p>在小块随机写过多的情况下，为了避免extent过多导致extent_map编码臃肿，当extent_map内的extent超过一定数量时，就要将extent均匀分成多个组分别编码保存。这里的一个组就是一个Shard。<br>拆分条件是使用ExtentMap::inline_bl的长度来判断的，当它超过一个阈值后，就会舍弃ExtentMap::inline_bl，转而使用ExtentMap::shards记录分片索引。<br>Shard属性如下：</p>
<pre><code>struct Shard {
    bluestore_onode_t::shard_info *shard_info = nullptr;
    unsigned extents = 0;  ///&lt; count extents in this shard
    bool loaded = false;   ///&lt; true if shard is loaded
    bool dirty = false;    ///&lt; true if shard is dirty and needs reencoding
};
struct shard_info {
    uint32_t offset = 0;  ///&lt; logical offset for start of shard
    uint32_t bytes = 0;   ///&lt; encoded bytes
};
</code></pre>
<p>Shard在数据库中的保存形式为：</p>
<pre><code>prefix: &quot;O&quot;
key: &quot;${oid编码}&quot; + &quot;${shard_info::offset}&quot; + &quot;x&quot;
value: {
    uint32_t blobs_num;
    {
        uint64_t   blobid;
        uint64_t   gap;
        uint32_t   Extent::blob_offset
        uint32_t   Extent::length; 
        Blob       blob;
    }
    ...
    {
        uint64_t   blobid;
        uint64_t   gap;
        uint32_t   Extent::blob_offset
        uint32_t   Extent::length; 
        Blob       blob;
    }
}
</code></pre>
<p>可见Shard value的编码格式和ExtentMap::inline_bl是一致的。</p>
<h2 id="Onode"><a href="#Onode" class="headerlink" title="Onode"></a>Onode</h2><p>Onode结构体用来记录一个对象的元数据，它的属性如下：</p>
<pre><code>struct Onode {
    ghobject_t oid; // 对象标志符
    string key;     // 数据库索引
    ExtentMap extent_map;
    bluestore_onode_t onode;
};
struct bluestore_onode_t {
  uint64_t nid;  // 用于索引omap
  uint64_t size = 0;  // 对象大小
  map&lt;string, bufferptr&gt; attrs;  // 对象的拓展属性
  vector&lt;shard_info&gt; extent_map_shards; // 分片索引
};
struct ghobject_t {
  hobject_t hobj;
  gen_t generation; // 对象版本号
  shard_id_t shard_id; // 纠删分片id，对于副本池对象来说这里是NO_SHARD
};
struct hobject_t {
    object_t oid;  // 对象名（字符串）
    snapid_t snap;  // 快照id（64位整数） 
    string nspace; // 命名空间
    int64_t pool; // 归属池
    uint32_t hash_reverse_bits;
};
</code></pre>
<p>Onode在数据库中的保存形式为：</p>
<pre><code>prefix: &quot;O&quot;
key: &quot;${oid编码}&quot; + &quot;o&quot;
value: {
    bluestore_onode_t onode;
    blob_map_t ExtentMap::spanning_blob_map;
    bufferlist ExtentMap::inline_bl; 
}
</code></pre>
<p>由此我们得到了获取对象数据的完整步骤：<br>（1）根据对象名计算出onode key<br>（2）根据onode key从数据库加载onode<br>（3）读取onode的extent_map，根据offset找到数据所在的extent<br>（4）找到extent从属的blob，将offset换算成blob内的相对偏移<br>（5）依据blob的相对偏移，得到数据所在的pextent<br>（6）依据pextent给定的坐标，从磁盘上读取数据<br>如果这个对象做了分片，那么在上述（2）、（3）步之间插入以下几步：<br>（7）读取onode的extent_map.shards，根据offset找到数据所在的shard<br>（8）根据shard offset，计算出shard key<br>（9）根据shard key从数据库加载shard value<br>（10）从shard value解码出extent插入到extent_map中</p>
