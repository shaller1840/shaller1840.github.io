<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/index/" class="article-date">
  <time class="dt-published" datetime="2024-06-19T03:42:30.914Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/index/">目录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ceph"><a href="#ceph" class="headerlink" title="ceph"></a>ceph</h1><p><a href="files/ceph_spawn.md">ceph spawn</a></p>
<h2 id="cephfs"><a href="#cephfs" class="headerlink" title="cephfs"></a>cephfs</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/index/" data-id="clxt3hcsz0001vieq7e7a4es7" data-title="目录" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/ceph_spawn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/ceph_spawn/" class="article-date">
  <time class="dt-published" datetime="2024-05-24T01:34:13.295Z" itemprop="datePublished">2024-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/ceph_spawn/">ceph spawn</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从ceph P版本开始，引入了一个spawn组件，用来实现协程相关的功能。这个组件实际上是复制于boost::asio，而boost打算在未来抛弃spawn这部分代码，换成其他实现形式，因此ceph不得不把这部分代码备份到自己的项目中。</p>
<h1 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h1><p>spawn方法用于将一个用户自定义函数封装成一个协程来运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Function, typename ExecutionContext, typename StackAllocator&gt;</span><br><span class="line">auto spawn(ExecutionContext&amp; ctx, Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)</span><br><span class="line">  -&gt; typename std::enable_if&lt;std::is_convertible&lt;</span><br><span class="line">       ExecutionContext&amp;, detail::net::execution_context&amp;&gt;::value &amp;&amp;</span><br><span class="line">       detail::is_stack_allocator&lt;typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">  spawn(ctx.get_executor(),</span><br><span class="line">      std::forward&lt;Function&gt;(function),</span><br><span class="line">      std::forward&lt;StackAllocator&gt;(salloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法接收3个参数：ExecutionContext、Function、StackAllocator；<br>其中，ExecutionContext可以是一个boost::asio::io_context实例，作为调度上下文；<br>StackAllocator用于申请内存作为协程栈，它决定了栈的位置和大小, StackAllocator可以不指定，默认为boost::context::default_stack<br>上述方法从ExecutionContext中取得Executor（调度队列），再传递给spawn的另一重载形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Function, typename Executor, typename StackAllocator&gt;</span><br><span class="line">auto spawn(const Executor&amp; ex, Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)</span><br><span class="line">  -&gt; typename std::enable_if&lt;detail::net::is_executor&lt;Executor&gt;::value &amp;&amp;</span><br><span class="line">       detail::is_stack_allocator&lt;typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">  spawn(detail::net::strand&lt;Executor&gt;(ex),</span><br><span class="line">      std::forward&lt;Function&gt;(function),</span><br><span class="line">      std::forward&lt;StackAllocator&gt;(salloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述重载形式会将Executor进一步封装成strand<Executor>传给下一个重载形式，strand<Executor>本质上也是一种调度队列，它与常规的Executor不同之处在于，常规的Executor支持多线程并发取任务执行，而strand<Executor>只支持顺序执行，不存在多任务并发的情况，适合任务间有顺序要求的场景。<br>这里使用strand<Executor>是为了在任务投递到相同队列的情况下，确保协程任务的后半段不会先于前半段执行，并且创建的子任务按顺序执行（减少资源竞争）。</Executor></Executor></Executor></Executor></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Function, typename Executor, typename StackAllocator&gt;</span><br><span class="line">auto spawn(const detail::net::strand&lt;Executor&gt;&amp; ex,</span><br><span class="line">           Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)</span><br><span class="line">  -&gt; typename std::enable_if&lt;detail::is_stack_allocator&lt;</span><br><span class="line">       typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">  spawn(bind_executor(ex, &amp;detail::default_spawn_handler),</span><br><span class="line">      std::forward&lt;Function&gt;(function),</span><br><span class="line">      std::forward&lt;StackAllocator&gt;(salloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述重载形式将strand<Executor> 绑定到一个default_spawn_handler上再传递到下一重载形式，default_spawn_handler是个空函数对象，仅作占位用途。<br>这里为什么选择将两个参数绑定到一起，而不是分别传递，可能是为了减少函数签名的复杂度。</Executor></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Handler, typename Function, typename StackAllocator&gt;</span><br><span class="line">auto spawn(Handler&amp;&amp; handler, Function&amp;&amp; function, StackAllocator&amp;&amp; salloc)</span><br><span class="line">  -&gt; typename std::enable_if&lt;!detail::net::is_executor&lt;typename std::decay&lt;Handler&gt;::type&gt;::value &amp;&amp;</span><br><span class="line">       !std::is_convertible&lt;Handler&amp;, detail::net::execution_context&amp;&gt;::value &amp;&amp;</span><br><span class="line">       !detail::is_stack_allocator&lt;typename std::decay&lt;Function&gt;::type&gt;::value &amp;&amp;</span><br><span class="line">       detail::is_stack_allocator&lt;typename std::decay&lt;StackAllocator&gt;::type&gt;::value&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">  using handler_type = typename std::decay&lt;Handler&gt;::type;</span><br><span class="line">  using function_type = typename std::decay&lt;Function&gt;::type;</span><br><span class="line"></span><br><span class="line">  auto ex = detail::net::get_associated_executor(handler);</span><br><span class="line">  auto a = detail::net::get_associated_allocator(handler);</span><br><span class="line"></span><br><span class="line">  detail::spawn_helper&lt;handler_type, function_type, StackAllocator&gt; helper;</span><br><span class="line">  helper.data_ = std::make_shared&lt;</span><br><span class="line">      detail::spawn_data&lt;handler_type, function_type, StackAllocator&gt; &gt;(</span><br><span class="line">        std::forward&lt;Handler&gt;(handler), true,</span><br><span class="line">        std::forward&lt;Function&gt;(function),</span><br><span class="line">        std::forward&lt;StackAllocator&gt;(salloc));</span><br><span class="line"></span><br><span class="line">  ex.dispatch(helper, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终spawn会调用到首参数为Handler的重载形式，这个重载形式真正实现了spawn的逻辑。<br>它先从Handler上取得绑定的调度队列和内存分配器，加上Function、StackAllocator和Handler自身构建一个spawn_data。这个spawn_data就代表了一个协程的完整信息。<br>spawn_helper是一个可调用对象，作为协程启动器来使用，它将spawn_data包含进去，在执行时会依据spawn_data提供的信息，负责构建并运行协程。<br>这里将spawn_helper作为一个任务投递到队列中，由后台线程调度执行。</p>
<h1 id="spawn-helper"><a href="#spawn-helper" class="headerlink" title="spawn_helper"></a>spawn_helper</h1><p>spawn_helper的具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Handler, typename Function, typename StackAllocator&gt;</span><br><span class="line">struct spawn_helper</span><br><span class="line">&#123;</span><br><span class="line">  void operator()()</span><br><span class="line">  &#123;</span><br><span class="line">    callee_.reset(new continuation_context());</span><br><span class="line">    callee_-&gt;context_ = boost::context::callcc(</span><br><span class="line">        std::allocator_arg, std::move(data_-&gt;salloc_),</span><br><span class="line">        [this] (boost::context::continuation&amp;&amp; c)</span><br><span class="line">        &#123;</span><br><span class="line">          std::shared_ptr&lt;spawn_data&lt;Handler, Function, StackAllocator&gt; &gt; data = data_;</span><br><span class="line">          data-&gt;caller_.context_ = std::move(c);</span><br><span class="line">          const basic_yield_context&lt;Handler&gt; yh(callee_, data-&gt;caller_, data-&gt;handler_);</span><br><span class="line">          try</span><br><span class="line">          &#123;</span><br><span class="line">            (data-&gt;function_)(yh);</span><br><span class="line">            if (data-&gt;call_handler_)</span><br><span class="line">            &#123;</span><br><span class="line">              (data-&gt;handler_)();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          catch (const boost::context::detail::forced_unwind&amp; e)</span><br><span class="line">          &#123;</span><br><span class="line">            throw; // must allow forced_unwind to propagate</span><br><span class="line">          &#125;</span><br><span class="line">          catch (...)</span><br><span class="line">          &#123;</span><br><span class="line">            auto callee = yh.callee_.lock();</span><br><span class="line">            if (callee)</span><br><span class="line">              callee-&gt;eptr_ = std::current_exception();</span><br><span class="line">          &#125;</span><br><span class="line">          boost::context::continuation caller = std::move(data-&gt;caller_.context_);</span><br><span class="line">          data.reset();</span><br><span class="line">          return caller;</span><br><span class="line">        &#125;);</span><br><span class="line">    if (callee_-&gt;eptr_)</span><br><span class="line">      std::rethrow_exception(std::move(callee_-&gt;eptr_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;continuation_context&gt; callee_;</span><br><span class="line">  std::shared_ptr&lt;spawn_data&lt;Handler, Function, StackAllocator&gt; &gt; data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>spawn_helper使用boost::context::callcc创建协程栈，并将一个lambda函数放在栈上运行。<br>可以看到在spawn_helper的lambda函数中，它先将spawn_data的共享指针缓存到协程栈上，避免协程信息丢失。（spawn_helper在运行完协程第一段后就会销毁掉，不能再依赖它维护spawn_data）。<br>然后基于现有信息创建了一个basic_yield_context传递给function，这个yield_context会贯穿整个协程流程，作为协程切换的句柄。<br>handler放在function之后执行，用于处理一些用户自定义的善后工作，也可以什么也不做。<br>可以注意到协程运行过程中抛出的异常，不会直接在协程上下文中处理，而是封装成一个exception_ptr，在协程调度完毕后，由协程的调用者来抛出异常。<br>spawn_helper只会运行协程的第一段逻辑，在协程第一次阻塞后，spawn_helper就会从boost::context::callcc的调用逻辑中返回。由boost::context::callcc创建的协程句柄会保存在spawn_helper的callee_变量上。<br>callee_变量被lambda函数捕获，并将其记录到yield_context上，加上lambda函数的入参构建的caller_变量，此时调用者和协程的上下文都能被yield_context索引到。</p>
<h1 id="spawn-data"><a href="#spawn-data" class="headerlink" title="spawn_data"></a>spawn_data</h1><p>spawn_data的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Handler, typename Function, typename StackAllocator&gt;</span><br><span class="line">struct spawn_data</span><br><span class="line">&#123;</span><br><span class="line">  Handler handler_;</span><br><span class="line">  bool call_handler_;</span><br><span class="line">  Function function_;</span><br><span class="line">  StackAllocator salloc_;</span><br><span class="line">  continuation_context caller_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Hanlder、Function、StackAllocator这些协程要素都由spawn_data维护生存期。<br>caller_ 对应调用者上下文，它的生存期也由spawn_data维护，</p>
<h1 id="basic-yield-context"><a href="#basic-yield-context" class="headerlink" title="basic_yield_context"></a>basic_yield_context</h1><p>basic_yield_context的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Handler&gt;</span><br><span class="line">class basic_yield_context</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  std::weak_ptr&lt;detail::continuation_context&gt; callee_;</span><br><span class="line">  detail::continuation_context&amp; caller_;</span><br><span class="line">  Handler handler_;</span><br><span class="line">  boost::system::error_code* ec_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>callee_对应协程上下文；<br>caller_对应调用者上下文；<br>handler_放在basic_yield_context中主要是为了方便取得executor 和 allocator;<br>ec_用于记录错误码，外部流程可以在唤醒协程前，将自己收集到的错误记录于此通知协程，以便于中止协程。</p>
<h1 id="async-completion"><a href="#async-completion" class="headerlink" title="async_completion"></a>async_completion</h1><p>STL 提供了promise 和 future 来实现多线程间的消息通知。<br>而为了能兼容更宽泛的消息通知形式（比如协程），boost提供了async_completion模板来构造消息的接收方和发送方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename CompletionToken, BOOST_ASIO_COMPLETION_SIGNATURE Signature&gt;</span><br><span class="line">struct async_completion &#123;</span><br><span class="line">  /// The real handler type to be used for the asynchronous operation.</span><br><span class="line">  typedef typename boost::asio::async_result&lt;</span><br><span class="line">    typename decay&lt;CompletionToken&gt;::type,</span><br><span class="line">      Signature&gt;::completion_handler_type completion_handler_type;</span><br><span class="line"></span><br><span class="line">  explicit async_completion(typename decay&lt;CompletionToken&gt;::type&amp; token)</span><br><span class="line">    : completion_handler(token),</span><br><span class="line">      result(completion_handler)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /// A copy of, or reference to, a real handler object.</span><br><span class="line">  completion_handler_type completion_handler;</span><br><span class="line"></span><br><span class="line">  /// The result of the asynchronous operation&#x27;s initiating function.</span><br><span class="line">  async_result&lt;typename decay&lt;CompletionToken&gt;::type, Signature&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里，使用result作为消息的接收方，对应future；<br>使用completion_handler作为消息的发送方，对应promise。</p>
<p>async_completion有2个模板参数：CompletionToken 和 Signature。<br>CompletionToken 包含了初始化所需的必要信息，它决定了async_completion的实例化类型；<br>Signature 是函数签名，对应了completion_handler 的调用形式，决定了消息的定义结构。</p>
<p>async_completion 初始化流程如下：</p>
<ol>
<li>根据CompletionToken类型找到对应的async_result模板, 决定result的类型；</li>
<li>从async_result模板得知对应的 completion_handler 的类型；</li>
<li>使用CompletionToken 初始化completion_handler；</li>
<li>使用completion_handler 初始化result；</li>
</ol>
<h1 id="coro-async-result、coro-handler"><a href="#coro-async-result、coro-handler" class="headerlink" title="coro_async_result、coro_handler"></a>coro_async_result、coro_handler</h1><p>下面以yield_context作为CompletionToken，举例说明async_completion的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Handler&gt;</span><br><span class="line">void my_func(basic_yield_context&lt;Handler&gt; yield) &#123;</span><br><span class="line">  // 基于yield_context构建异步上下文completion</span><br><span class="line">  boost::asio::async_completion&lt;</span><br><span class="line">    basic_yield_context&lt;Handler&gt;, void()</span><br><span class="line">  &gt; completion(yield);</span><br><span class="line"></span><br><span class="line">  // 从异步上下文completion中取出completion_handler传递给异步流程</span><br><span class="line">  auto async_thread = thread(</span><br><span class="line">    [completion_handler=completion.completion_handler]&#123;</span><br><span class="line">      sleep(5);</span><br><span class="line">      // 异步流程将completion_handler作为回调函数，投递到调度队列去重新运行协程</span><br><span class="line">      auto executor = boost::asio::get_associated_executor(completion_handler);</span><br><span class="line">      auto allocator = boost::asio::get_associated_allocator(completion_handler);</span><br><span class="line">      executor.post(move(completion_handler), allocator);</span><br><span class="line">    &#125;);</span><br><span class="line">  async_thread.detach();</span><br><span class="line"></span><br><span class="line">  // 当前流程使用completion.result进行等待，由completion_handler唤醒</span><br><span class="line">  completion.result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当yield_context作为CompletionToken时，找到的async_result模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Handler, typename ReturnType&gt;</span><br><span class="line">class SPAWN_NET_NAMESPACE::async_result&lt;spawn::basic_yield_context&lt;Handler&gt;, ReturnType()&gt;</span><br><span class="line">  : public spawn::detail::coro_async_result&lt;Handler, void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  explicit async_result(</span><br><span class="line">    typename spawn::detail::coro_async_result&lt;Handler,</span><br><span class="line">      void&gt;::completion_handler_type&amp; h)</span><br><span class="line">    : spawn::detail::coro_async_result&lt;Handler, void&gt;(h)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Handler&gt;</span><br><span class="line">class coro_async_result&lt;Handler, void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  using completion_handler_type = coro_handler&lt;Handler, void&gt;;</span><br><span class="line">  using return_type = void;</span><br><span class="line"></span><br><span class="line">  explicit coro_async_result(completion_handler_type&amp; h)</span><br><span class="line">    : handler_(h),</span><br><span class="line">      caller_(h.caller_),</span><br><span class="line">      ready_(2)</span><br><span class="line">  &#123;</span><br><span class="line">    h.ready_ = &amp;ready_;</span><br><span class="line">    out_ec_ = h.ec_;</span><br><span class="line">    if (!out_ec_) h.ec_ = &amp;ec_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void get()</span><br><span class="line">  &#123;</span><br><span class="line">    // Must not hold shared_ptr while suspended.</span><br><span class="line">    handler_.callee_.reset();</span><br><span class="line"></span><br><span class="line">    if (--ready_ != 0)</span><br><span class="line">      caller_.resume(); // suspend caller</span><br><span class="line">    if (!out_ec_ &amp;&amp; ec_) throw boost::system::system_error(ec_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  completion_handler_type&amp; handler_;</span><br><span class="line">  continuation_context&amp; caller_;</span><br><span class="line">  std::atomic&lt;long&gt; ready_;</span><br><span class="line">  boost::system::error_code* out_ec_;</span><br><span class="line">  boost::system::error_code ec_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可见 yield_context 将async_result模板实例化成一个coro_async_result类型。<br>coro_async_result 初始化时会将自己的ready_、ec_成员共享给completion_handler，而completion_handler把自己的caller_成员共享给coro_async_result。<br>当我们调用coro_async_result的get方法时，它会先将handler_的callee_清空，所以必须在调用前，把completion_handler转移到其他地方。<br>然后它会使用ready_的值来判断get 和 completion_handler的先后顺序，ready_初始值为2，get 和 completion_handler都会令它的值减一，最终归0。<br>如果是get先调用，那么ready_会下降到1，此时需要通过caller_.resume方法，切回调用者上下文，阻塞协程逻辑，等待下一步唤醒；如果是completion_handler先执行，那么那么ready_会下降到0，此时不需要切换协程，继续运行当前流程即可。</p>
<p>coro_async_result 对应的completion_handler类型为coro_handler：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Handler&gt;</span><br><span class="line">class coro_handler&lt;Handler, void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  coro_handler(basic_yield_context&lt;Handler&gt; ctx)</span><br><span class="line">    : callee_(ctx.callee_.lock()),</span><br><span class="line">      caller_(ctx.caller_),</span><br><span class="line">      handler_(ctx.handler_),</span><br><span class="line">      ready_(0),</span><br><span class="line">      ec_(ctx.ec_)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void operator()()</span><br><span class="line">  &#123;</span><br><span class="line">    *ec_ = boost::system::error_code();</span><br><span class="line">    if (--*ready_ == 0)</span><br><span class="line">      callee_-&gt;resume();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void operator()(boost::system::error_code ec)</span><br><span class="line">  &#123;</span><br><span class="line">    *ec_ = ec;</span><br><span class="line">    if (--*ready_ == 0)</span><br><span class="line">      callee_-&gt;resume();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//private:</span><br><span class="line">  std::shared_ptr&lt;continuation_context&gt; callee_;</span><br><span class="line">  continuation_context&amp; caller_;</span><br><span class="line">  Handler handler_;</span><br><span class="line">  std::atomic&lt;long&gt;* ready_;</span><br><span class="line">  boost::system::error_code* ec_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>coro_handler初始化时，从basic_yield_context复制了一份callee_的强引用，确保callee_不会在回调完成前析构掉。这也是为何basic_yield_context只保留callee_弱引用的原因，因为协程总会在切出前把callee_的强引用复制给一个completion_handler，basic_yield_context只需发挥一个桥梁的作用，将callee_的引用过渡给新的流程。<br>coro_handler还需要从basic_yield_context取得caller_引用记录下来，待会传递给coro_async_result使用。<br>coro_handler被调用时，它会判断ready_值，当ready_下降到0时，意味者result.get已被调用，那么执行callee_-&gt;resume方法，跳转到协程上下文继续运行；如果ready_不为0，意味着协程还没有陷入阻塞，不必唤醒，什么也不做。</p>
<p>async_result 和 completion_handler 是成对的，两者都是不可重入类型，只能调用一次，能在一定程度上容忍乱序执行，但是还存在一个缺陷，复现过程如下：<br>（1）线程1：执行result.get，–*ready_ &#x3D;&#x3D; 1；<br>（2）线程2：执行completion_handler，–*ready_ &#x3D;&#x3D; 0；<br>（3）线程2：执行callee_-&gt;resume()，但是此时线程1尚未让出协程执行权，触发断言错误崩溃<br>（4）线程1：执行caller_.resume()</p>
<p>因此最好使用strand或其他方法来确保completion_handler 和 result.get 不会同时执行。</p>
<h1 id="continuation-context"><a href="#continuation-context" class="headerlink" title="continuation_context"></a>continuation_context</h1><p>上面提到的callee 和 caller 都属于continuation_context类型，它们分别代表协程上下文和调用者上下文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class continuation_context</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  boost::context::continuation context_;</span><br><span class="line">  std::exception_ptr eptr_;</span><br><span class="line"></span><br><span class="line">  void resume()</span><br><span class="line">  &#123;</span><br><span class="line">    context_ = context_.resume();</span><br><span class="line"></span><br><span class="line">    if (eptr_)</span><br><span class="line">      std::rethrow_exception(std::move(eptr_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体比较简单，它是对boost::context::continuation的封装，主要是增加了一个exception_ptr成员，用来保存协程运行过程中抛出的异常，等到流程返回调用者上下文后，再将异常抛出，避免在协程栈上做回溯动作，造成不可控制的后果（协程目前只处理了forced_unwind类型的异常，其他类型的异常可能会一直向上回溯，突破栈的界限）。<br>通过调用continuation::resume函数来跳转到目标上下文运行，当context_对应协程上下文时，是切入协程；当context_对应调用者上下文时，是切出协程。<br>在resume运行期间context_会被置为空；仅当resume完毕后才会返回一个新的continuation赋予context_，达到更新上下文地址的目的，同时也能在一定程度上避免多线程运行在同一个上下文。</p>
<h1 id="continuation"><a href="#continuation" class="headerlink" title="continuation"></a>continuation</h1><p>continuation的定义也很简单，它是对fcontext_t的封装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class continuation &#123;</span><br><span class="line">private:</span><br><span class="line">  detail::fcontext_t  fctx_&#123; nullptr &#125;;</span><br><span class="line"></span><br><span class="line">  continuation( detail::fcontext_t fctx) noexcept :</span><br><span class="line">      fctx_&#123; fctx &#125; &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  continuation resume() &amp; &#123;</span><br><span class="line">      return std::move( * this).resume();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  continuation resume() &amp;&amp; &#123;</span><br><span class="line">      BOOST_ASSERT( nullptr != fctx_);</span><br><span class="line">      return &#123; detail::jump_fcontext(</span><br><span class="line">                  std::exchange( fctx_, nullptr),</span><br><span class="line">                  nullptr).fctx &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里fcontext_t是一个void*类型，它对应目标上下文的栈顶地址，continuation::resume就是通过jump_fcontext切换上下文。<br>可以注意到在将fctx_传给jump_fcontext后，fctx_就被交换为空值；在jump_fcontext返回新的fctx后，才重构一个新的continuation输出，以此来转移协程执行权。</p>
<h1 id="jump-fcontext"><a href="#jump-fcontext" class="headerlink" title="jump_fcontext"></a>jump_fcontext</h1><p>jump_fcontext的函数签名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void*   fcontext_t;</span><br><span class="line"></span><br><span class="line">struct transfer_t &#123;</span><br><span class="line">    fcontext_t  fctx;</span><br><span class="line">    void    *   data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">transfer_t jump_fcontext( fcontext_t const to, void * vp);</span><br></pre></td></tr></table></figure>
<p>jump_fcontext是一个用汇编代码实现的函数，它的效果是切换到目标上下文继续运行，具体步骤如下：</p>
<ol>
<li>保存当前的寄存器值到栈上（入栈）</li>
<li>复制SP寄存器的值到AX寄存器上（准备返回值1）</li>
<li>用参数to重置SP寄存器的值（切栈）</li>
<li>从新的栈上还原寄存器值 （出栈）</li>
<li>将参数vp的值保存到DX寄存器上 （准备返回值2）</li>
<li>复制AX寄存器的值（源栈顶地址）到DI寄存器上 （准备调用参数1，后面介绍）</li>
<li>从新的栈上取出返回地址，使用jmp指令跳转到目标流程继续运行 （函数返回）</li>
</ol>
<p>这个函数的效果可以分2个视角来看待：</p>
<ol>
<li>线程的视角：jump_fcontext将当前线程的栈切换为参数to给定的栈，运行地址也切换为新的，它把原来的栈顶地址和参数vp通过返回值的形式传输到新的上下文，这样就实现了2个上下文间的消息传递，并且新的上下文拥有源栈顶地址可以随时跳转回去。<br><img src="/files/ceph_spawn/jump_fcontext.png"></li>
<li>函数的视角：jump_fcontext似乎和普通的函数没什么区别，它可以用于唤醒参数to代表的目标上下文继续运行，并将参数vp作为消息发送过去，然后当前流程会一直阻塞在jump_fcontext这里，直至收到消息被唤醒，此时jump_fcontext会返回发送方的上下文地址fctx以及消息data。<br><img src="/files/ceph_spawn/jump_fcontext2.png"></li>
</ol>
<h1 id="callcc"><a href="#callcc" class="headerlink" title="callcc"></a>callcc</h1><p>boost::context::callcc 用于将给定的函数封装到协程中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename StackAlloc, typename Fn &gt;</span><br><span class="line">continuation</span><br><span class="line">callcc( std::allocator_arg_t, StackAlloc &amp;&amp; salloc, Fn &amp;&amp; fn) &#123;</span><br><span class="line">    using Record = detail::record&lt; continuation, StackAlloc, Fn &gt;;</span><br><span class="line">    return continuation&#123;</span><br><span class="line">                detail::create_context1&lt; Record &gt;(</span><br><span class="line">                        std::forward&lt; StackAlloc &gt;( salloc), std::forward&lt; Fn &gt;( fn) ) &#125;.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做了几件事：</p>
<ol>
<li>使用create_context1创建协程，返回协程栈顶地址</li>
<li>用协程栈顶地址初始化一个continuation</li>
<li>调用continuation的resume方法运行协程</li>
<li>返回运行后的新continuation（封装了新的协程栈顶地址）</li>
</ol>
<h1 id="create-context1"><a href="#create-context1" class="headerlink" title="create_context1"></a>create_context1</h1><p>create_context1函数的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Record, typename StackAlloc, typename Fn &gt;</span><br><span class="line">fcontext_t create_context1( StackAlloc &amp;&amp; salloc, Fn &amp;&amp; fn) &#123;</span><br><span class="line">  auto sctx = salloc.allocate();</span><br><span class="line">  // reserve space for control structure</span><br><span class="line">  void * storage = reinterpret_cast&lt; void * &gt;(</span><br><span class="line">      ( reinterpret_cast&lt; uintptr_t &gt;( sctx.sp) - static_cast&lt; uintptr_t &gt;( sizeof( Record) ) ) &amp; ~static_cast&lt; uintptr_t &gt;( 0xff) );</span><br><span class="line">  // placment new for control structure on context stack</span><br><span class="line">  Record * record = new ( storage) Record&#123;</span><br><span class="line">          sctx, std::forward&lt; StackAlloc &gt;( salloc), std::forward&lt; Fn &gt;( fn) &#125;;</span><br><span class="line">  // 64byte gab between control structure and stack top</span><br><span class="line">  // should be 16byte aligned</span><br><span class="line">  void * stack_top = reinterpret_cast&lt; void * &gt;(</span><br><span class="line">          reinterpret_cast&lt; uintptr_t &gt;( storage) - static_cast&lt; uintptr_t &gt;( 64) );</span><br><span class="line">  void * stack_bottom = reinterpret_cast&lt; void * &gt;(</span><br><span class="line">          reinterpret_cast&lt; uintptr_t &gt;( sctx.sp) - static_cast&lt; uintptr_t &gt;( sctx.size) );</span><br><span class="line">  // create fast-context</span><br><span class="line">  const std::size_t size = reinterpret_cast&lt; uintptr_t &gt;( stack_top) - reinterpret_cast&lt; uintptr_t &gt;( stack_bottom);</span><br><span class="line">  const fcontext_t fctx = make_fcontext( stack_top, size, &amp; context_entry&lt; Record &gt;);</span><br><span class="line">  BOOST_ASSERT( nullptr != fctx);</span><br><span class="line">  // transfer control structure to context-stack</span><br><span class="line">  return jump_fcontext( fctx, record).fctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的步骤可以简要描述为：</p>
<ol>
<li>使用参数StackAlloc分配了一块内存，使用内存的尾部作为栈顶（栈向低地址延伸）</li>
<li>在栈顶创建一个record结构，用来保存协程信息，比如栈地址、栈大小、栈分配器、用户函数等</li>
<li>使用make_fcontext在新的栈顶上（record的上面）伪造一个栈帧，将context_entry函数地址作为返回地址保存在栈帧中（实际的实现会更复杂一些）<br><img src="/files/ceph_spawn/3.png"></li>
<li>使用jump_fcontext跳转到伪造的栈帧上，并将record地址作为消息传递过去</li>
<li>jump_fcontext函数退栈，访问到返回地址时，变成对context_entry函数的调用（这里利用到了jump_fcontext时保存到DI寄存器上的源栈顶地址，作为函数的第一参数，第二参数则继承于jump_fcontext的第二参数vp），而不是返回到上一级（实际上也不存在上一级）</li>
<li>进入context_entry函数后，先从参数取得record地址缓存到栈上，再通过jump_fcontext跳转回create_context1的上下文，这样两边的跳转通道都建立好了</li>
<li>create_context1函数返回最新的目标上下文地址，也就是context_entry函数的栈顶地址</li>
</ol>
<h1 id="context-entry"><a href="#context-entry" class="headerlink" title="context_entry"></a>context_entry</h1><p>context_entry类似于协程的main函数，下面是它的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Rec &gt;</span><br><span class="line">void context_entry( transfer_t t) noexcept &#123;</span><br><span class="line">    // transfer control structure to the context-stack</span><br><span class="line">    Rec * rec = static_cast&lt; Rec * &gt;( t.data);</span><br><span class="line">    BOOST_ASSERT( nullptr != t.fctx);</span><br><span class="line">    BOOST_ASSERT( nullptr != rec);</span><br><span class="line">    try &#123;</span><br><span class="line">        // jump back to `create_context()`</span><br><span class="line">        t = jump_fcontext( t.fctx, nullptr);</span><br><span class="line">        // start executing</span><br><span class="line">        t.fctx = rec-&gt;run( t.fctx);</span><br><span class="line">    &#125; catch ( forced_unwind const&amp; ex) &#123;</span><br><span class="line">        t = &#123; ex.fctx, nullptr &#125;;</span><br><span class="line">#ifndef BOOST_ASSERT_IS_VOID</span><br><span class="line">        const_cast&lt; forced_unwind &amp; &gt;( ex).caught = true;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    BOOST_ASSERT( nullptr != t.fctx);</span><br><span class="line">    // destroy context-stack of `this`context on next context</span><br><span class="line">    ontop_fcontext( t.fctx, rec, context_exit&lt; Rec &gt;);</span><br><span class="line">    BOOST_ASSERT_MSG( false, &quot;context already terminated&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中t.data就对应之前提到的record地址，t.fctx则是调用者的栈顶地址。<br>context_entry在运行record::run前使用jump_fcontext返回了原本的上下文，告知调用者进入协程的通道已准备就绪，下次通过jump_fcontext进入就无需携带任何消息了。<br>record::run函数的实现很简单，就只是将调用者的栈顶地址封装成一个continuation，作为参数传递给业务函数fn_并运行，业务函数需要切出上下文时就会用到这个continuation。这里的fn_实际上就对应spawn_helper处的lambda函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fcontext_t record::run( fcontext_t fctx) &#123;</span><br><span class="line">  continuation c&#123; fctx &#125;;</span><br><span class="line">  // invoke context-function</span><br><span class="line">  c = std::invoke( fn_, std::move( c) )</span><br><span class="line">  return std::exchange( c.fctx_, nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>context_entry用try catch 包围了record::run函数，用于捕获forced_unwind类型的异常，context_entry会从该异常中取出新的调用者栈顶地址，而不是从record::run函数的返回值获取。这在需要提前终止协程的情况下很有用。<br>在流程的最后（无论是record::run正常返回，还是捕获到异常提前退出），通过ontop_fcontext函数返回调用者上下文，并触发context_exit函数清理协程栈。</p>
<h1 id="ontop-fcontext"><a href="#ontop-fcontext" class="headerlink" title="ontop_fcontext"></a>ontop_fcontext</h1><p>ontop_fcontext函数的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfer_t ontop_fcontext( fcontext_t const to, void * vp, transfer_t (* fn)( transfer_t) );</span><br></pre></td></tr></table></figure>
<p>ontop_fcontext函数也是一个用汇编代码实现的函数，它的效果和 jump_fcontext类似，都会切换到目标上下文，但是jump_fcontext在最后是从栈上取出返回地址跳转，而ontop_fcontext则是使用第三个参数（函数指针）作为跳转地址，前两个参数作为函数传参，待目标函数执行完成后，才从当前栈上取出地址返回，相当于ontop_fcontext不光完成了上下文切换，还在切换后多执行了一个函数，这个函数的返回值限定为fcontext_t，必须和jump_fcontext 保持一致，这样才能顺利衔接。</p>
<h1 id="协程的销毁"><a href="#协程的销毁" class="headerlink" title="协程的销毁"></a>协程的销毁</h1><p>销毁协程采用context_exit函数，它调用给定的record实例的deallocate来完成工作，最后通过返回空地址来告诉调用者协程运行完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Rec &gt;</span><br><span class="line">transfer_t context_exit( transfer_t t) noexcept &#123;</span><br><span class="line">    Rec * rec = static_cast&lt; Rec * &gt;( t.data);</span><br><span class="line">    // destroy context stack</span><br><span class="line">    rec-&gt;deallocate();</span><br><span class="line">    return &#123; nullptr, nullptr &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>record::deallocate函数通过调用静态方法destroy，对record结构体进行析构，并调用栈分配器的方法摧毁整个协程栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void record::deallocate() noexcept &#123;</span><br><span class="line">  destroy( this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void destroy( record * p) noexcept &#123;</span><br><span class="line">  typename std::decay&lt; StackAlloc &gt;::type salloc = std::move( p-&gt;salloc_);</span><br><span class="line">  stack_context sctx = p-&gt;sctx_;</span><br><span class="line">  // deallocate record</span><br><span class="line">  p-&gt;~record();</span><br><span class="line">  // destroy stack with stack allocator</span><br><span class="line">  salloc.deallocate( sctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上所述，协程的创建、切入、切出、销毁可以用下面一幅图来描述：<br><img src="/files/ceph_spawn/4.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/ceph_spawn/" data-id="clxt3hct80003vieqcdinds1n" data-title="ceph spawn" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/references" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/references/" class="article-date">
  <time class="dt-published" datetime="2024-05-18T09:06:52.885Z" itemprop="datePublished">2024-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/references/">好文推荐</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WQzGT_3QSt6sPE7Husbd3Q">XEOS 对象存储深度结合 Alluxio 分布式缓存系统， GPU 利用率提高至 90% 以上</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/re49NBsGjq8YmPQZhF4oQg">Xline 0.7重构性能分析总述</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CNZzmazeKqvBCYuK8Od-Dw">DAOS: 一种面向SCM的可扩展高性能存储栈</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/references/" data-id="clxt3hcto0008vieqbqhq1pqq" data-title="好文推荐" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/sst" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/sst/" class="article-date">
  <time class="dt-published" datetime="2024-05-13T16:07:05.286Z" itemprop="datePublished">2024-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/sst/">rocksdb SST格式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SST文件格式"><a href="#SST文件格式" class="headerlink" title="SST文件格式"></a>SST文件格式</h1><p>一个SST文件的格式如下：<br><img src="/files/sst/1.png"><br>可以观察到一个SST文件内部划分成多种类型的块：</p>
<ol>
<li>data block 用来保存一定数量的用户键值对。当data block达到一定尺寸后，就需要生成下一个data block容纳更多的键值对。</li>
<li>filter block 使用布隆过滤器来加快判断目标key是否位于当前SST文件中</li>
<li>index block 记录每个data block的位置和key范围，用于筛选出目标key所在的data block</li>
<li>stats block 用来记录SST文件的一些基本信息，如所有data block的总大小、index block的大小、fiter block的大小、键值对数量、data block数量等。</li>
<li>mataindex block 记录每个meta block的位置和大小</li>
<li>footer用于记录mataindex block 和 index block 的位置和大小，还包括一个魔法数。</li>
</ol>
<p>SST编码格式的一个特征在于它总是将索引信息放在文件的尾部，因为它的索引信息是在数据编码的过程中逐渐完善的，把索引信息放在最后更加方便，并且也能用于检查完整性。也因为如此，解码时需要从尾部开始反向进行。</p>
<h1 id="Data-Block"><a href="#Data-Block" class="headerlink" title="Data Block"></a>Data Block</h1><p>在data block内部，每个用户键值对的编码格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_bytes: varint32</span><br><span class="line">unshared_bytes: varint32</span><br><span class="line">value_length: varint32</span><br><span class="line">key_delta: char[unshared_bytes]</span><br><span class="line">value: char[value_length]</span><br></pre></td></tr></table></figure>
<p>其中shared_bytes表示key的共享前缀长度，unshared_bytes表示key的后缀长度，value_length表示值长度，key_delta保存了key的后缀部分，value保存了值内容。<br>data block并不会为每个键值对都记录完整的key，只有第一个键值对会保存完整的key，后续的键值对只需记录与前一个key不同的后缀部分以及相同的前缀长度，以节省存储空间。<br>前缀压缩存储的缺点在于只支持顺序查找，为了能兼顾空间和效率，这里采用一个折中方案，每隔n个键值对作为前缀压缩的一个分组，每个分组的第一个键值对放弃前缀压缩（shared_bytes &#x3D;&#x3D; 0），只对该分组后续的键值对采用前缀压缩。<br>每个分组的首地址记为一个restart_point，可以作为二分查找的落点。当需要在data block内搜索一个key时，可以先跳转到中间的restart_point处，顺序检查当前分组是否存在目标key；如果不存在目标key，则根据大小关系，选择跳转到前面的restart_point或者后面的restart_point继续搜索。</p>
<p>为了进一步加速查找，还可以增加一个hash表（buckets数组），建立key –&gt; hash –&gt; restart_point的映射关系，省去二分查找的过程。<br>hash表的使用方法为，先根据目标key计算一个hash值，再使用hash值对hash表尺寸取模（hash % num_buckets），得到bucket_id，从buckets[bucket_id]处取得重启点位置。<br>考虑到这种hash映射可能是不均匀的，对于没有分配到重启点的bucket，记为kNoEntry状态(255)；对于多个重启点映射的bucket，记为kCollision状态(254)；这两种状态的bucket都不可用，如果key命中了这样的bucket，则退化为二分查找。</p>
<p>hash表和重启点数组都放在data block的尾部保存，其编码格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restarts: varint32[num_restarts]</span><br><span class="line">buckets:  varint8[num_buckets]</span><br><span class="line">num_buckets: varint16</span><br><span class="line">block_footer: varint32 // index_type &lt;&lt; 31 | num_restarts</span><br></pre></td></tr></table></figure>
<p>最后一项block_footer使用低31位记录重启点数量，使用最高位记录是否启用hash表（index_type），为0时表示不启用，为1时表示启用。不启用hash表时，buckets和num_buckets字段会省去。</p>
<p>hash表有一些生成限制，比如：</p>
<ol>
<li>加入hash表后，data block的大小不能超过64KB</li>
<li>重启点的序号不能超过253（254和255是保留值）</li>
</ol>
<p>如果不能满足条件，则会放弃生成hash表</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/sst/" data-id="clxt3hctr000avieqh9dw9fts" data-title="rocksdb SST格式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/cephfs_mdcache" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/cephfs_mdcache/" class="article-date">
  <time class="dt-published" datetime="2024-05-08T13:37:03.740Z" itemprop="datePublished">2024-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/cephfs_mdcache/">cephfs元数据缓存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h1><p>为了便于路径检索，元数据采用树的形式组织在缓存中；<br>元数据分为3类：inode、dirfrag、dentry；<br>一个inode可持有多个dirfrag，一个dirfrag包含多个dentry，一个dentry唯一指向一个inode；<br>这里的dirfrag就是一个目录分片，最初的时候一个inode只持有一个dirfrag，<br>随着用户创建更多的文件或子目录，dirfrag中的dentry就会越来越多，<br>达到一定程度后，mds就会将原有的dirfrag分裂成多个新的dirfrag，<br>令dentry重新分配到这些新的dirfrag中，以避免臃肿的目录影响存取效率；<br>dentry分布到哪一个dirfrag中，是由它的name的哈希值决定的；<br>不同的dirfrag对应不同的哈希区间，<br>哈希值落在区间内的dentry就会分配到这个dirfrag中保存；<br>只有目录类型的inode才会持有dirfrag，文件类型的inode没有。<br><img src="/files/cephfs_mdcache/18.png"></p>
<h1 id="日志链表"><a href="#日志链表" class="headerlink" title="日志链表"></a>日志链表</h1><p>随着元数据不断被修改，日志文件会越来越大，达到一定尺寸后，就需要早期的修改flush到元数据池中，然后释放掉相关的日志片段；<br>每当mds提交一个日志记录，日志文件的seq就会+1；<br>mds将日志分为多个LogSegment，每个LogSegment对应一个seq周期，内含多种类型的链表；<br>每个链表都串接着特定类型的元数据，这些元数据都是这个LogSegment周期内被修改过的；<br>这种组织形式的目的是为了方便在日志裁剪时，快速找到需要flush的元数据；<br>LogSegment按照seq排列，便于确定裁剪顺序；而元数据在链表上则没有排列顺序的要求；<br>如果一个元数据在多个周期都修改过，那么它只会链接到最新的LogSegment中；<br>LogSegment只会链接dirty元数据，<br>元数据经过flush变成clean状态后，<br>就会立即从LogSegment中移除；<br>当一个LogSegment上已经没有dirty元数据后，<br>与它相关的日志对象就会随之一起被删除掉。<br><img src="/files/cephfs_mdcache/19.png"></p>
<h1 id="缓存裁剪"><a href="#缓存裁剪" class="headerlink" title="缓存裁剪"></a>缓存裁剪</h1><p>mds以dentry为单位管理LRU，当缓存尺寸超过阈值时，mds就会将靠近LRU尾部的dentry从缓存释放掉；<br>新加入LRU的dentry，会插入到LRU中间3:7的位置，这会将该位置后的dentry向后挤，超过边界的dentry就会被裁剪掉；<br>可见位于插入点之前的dentry会相对安全一些，新插入的dentry并不会动摇它们的地位;<br><img src="/files/cephfs_mdcache/20.png"><br>如果一个dentry已经在LRU中，且最近被访问过，那么就会被执行touch操作，提升到LRU头部的位置；<br>虽然touch操作不会改变LRU长度，但是它会将前半部的一个dentry挤到后半部，使之出现被裁剪的风险；<br><img src="/files/cephfs_mdcache/21.png"><br>考虑到新加入的dentry可能只是一时热度，后续不再访问，而那些反复访问的dentry才具有常驻热度；<br>为了避免新来的dentry干扰常驻dentry的优先级，将LRU分成2个部分使得这两类dentry分开竞争。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/cephfs_mdcache/" data-id="clxt3hctk0005vieq3kt9a4ua" data-title="cephfs元数据缓存" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/cephfs_object" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/cephfs_object/" class="article-date">
  <time class="dt-published" datetime="2024-05-07T13:36:23.758Z" itemprop="datePublished">2024-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/cephfs_object/">cephfs存储格式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="dirfrag对象"><a href="#dirfrag对象" class="headerlink" title="dirfrag对象"></a>dirfrag对象</h1><p>cephfs的目录支持分片特性，即将一个目录的内容拆分成多个分片保存，每个分片称为一个dirfrag;<br>一个dirfrag对应一段哈希区间，这里取哈希区间的首地址作为dirfrag的哈希值；<br>dirfrag对象，以目录inode的id为前缀，dirfrag的哈希值为后缀命名，中间以”.”号分隔；<br>如果dirfrag属于id&#x3D;&#x3D;1003的inode，它的哈希值为0x8000，那么这个dirfrag的对象名为1003.8000;<br>cephfs将一个dirfrag作为一个对象保存在元数据池中，mds通过读取这些对象可以在缓存中构造出一棵目录树；<br>dirfrag的基本属性，如文件数、子目录数等，会保存在对象的omap_header中；<br>dirfrag包含的每一个dentry，都会作为一条omap entry保存在对象中，存储格式如下：<br><img src="/files/cephfs_object/8.png"></p>
<p>在不考虑快照的情况下，snap_first默认为2，snap_last默认为“head”<br>cephfs支持硬链接，即多个dentry指向相同的inode，因此对于主链接和副链接而言，它们的dentry_value形式有所不同<br>对于主链接的情况，dentry_value &#x3D; dentry_type + inode，这里就是inode结构体的常规保存位置；<br>对于副链接的情况，dentry_value &#x3D; dentry_type + inode_id + inode_type，只提供查找inode的最低限度信息；<br><img src="/files/cephfs_object/7.png"></p>
<p>下面简述如何根据dirfrag对象中的信息，检索路径&#x2F;dir1&#x2F;dir2&#x2F;file：<br><img src="/files/cephfs_object/9.png"></p>
<ol>
<li>已知根目录inode单独保存在1.0000.inode对象中，和其他inode不一样，需要特殊对待；</li>
<li>读取1.0000.inode对象，解码得到root inode，id&#x3D;&#x3D;1，分片数为4；</li>
<li>字符串”dir1”的哈希值为0x4125，命中0x4000这个分片；</li>
<li>读取1.4000对象的omap，查询到dir1_head条目，解码得到新的inode，id&#x3D;&#x3D;1001，分片数为2；</li>
<li>字符串”dir2”的哈希值为0x875a，命中0x8000这个分片；</li>
<li>读取1001.8000对象，查询到dir2_head条目，解码得到新的inode，id&#x3D;&#x3D;1002，分片数为1；</li>
<li>字符串”file“的哈希值为0xa834，命中0x0000这个分片；</li>
<li>读取1002.0000对象，查询到file_head条目，解码得到新的inode，id&#x3D;&#x3D;1003；</li>
<li>路径已经用完了，本次检索到此结束</li>
</ol>
<h1 id="stray对象"><a href="#stray对象" class="headerlink" title="stray对象"></a>stray对象</h1><p>cephfs中有一类特殊的目录叫stray目录，用来保存那些刚删除不久,还没有清理数据的inode，这些目录对用户不可见；<br>stray dirfrag的保存格式和普通dirfrag是一样的，都会在元数据池中生成对应的对象；<br>不同rank的mds拥有各自的stray目录，同时为了避免一个目录下保存过多文件，需要分成多个stray目录来保存，单个stray目录不再进行分片，简化处理逻辑。<br><img src="/files/cephfs_object/10.png"><br>stray inode id为6xx这种形式，如608、609、60a、60b，并且只有一个哈希值为0000的分片，所以stray dirfrag对象的名称会是608.0000这种样子；<br>stray dirfrag下的dentry都是特殊命名的，以它指向的inode的id作为名称，如果dentry指向一个id&#x3D;&#x3D;1005的inode，那么dentry_name&#x3D;&#x3D;“1005”;<br><img src="/files/cephfs_object/11.png"><br>stray dirfrag中的dentry都是主链接，不存在多链接的情况；<br>在其他方面，stray dirfrag的表现和普通dirfrag几乎是一样的。</p>
<h1 id="mdlog对象"><a href="#mdlog对象" class="headerlink" title="mdlog对象"></a>mdlog对象</h1><p>mdlog是cephfs中的日志文件，用于确保分布式事务的原子性和故障恢复；<br>mdlog会按照特定的file_layout，分割成多个等长对象保存在元数据池；<br>mdlog对象名后缀从0000开始依次递增，前缀为2xx的形式，xx表示mds rank id，比如rank 3 mds的日志首对象为203.0000；<br>后缀为0000的对象比较特殊，不记录日志内容，而是记录日志的起始地址，尾地址，过期区间这些信息;<br><img src="/files/cephfs_object/13.png"><br>日志文件总是不断地追加写，尾地址是单调递增的，但是它的实际对象数是有限的，一般只能保留128个对象，<br>当日志对象数超过阈值后，就需要将早期的对象内容转储后删除掉，并标记对应的地址范围为过期的；<br>故障恢复时会跳过过期区域，从第一个有效地址开始读取播放内容；<br><img src="/files/cephfs_object/12.png"></p>
<h1 id="purge-queue对象"><a href="#purge-queue对象" class="headerlink" title="purge_queue对象"></a>purge_queue对象</h1><p>purge_queue其实是一种特殊的日志文件，它的格式和mdlog几乎是一致的，只是保存的内容不太一样；<br>mdlog保存的是元数据操作记录，而purge_queue保存的则是对象清理任务；<br>purge_queue对象以5xx为前缀，xx对应一个rank id；<br><img src="/files/cephfs_object/14.png"></p>
<p>每当一个文件被删除后，就会添加一个对象清理任务到purge_queue中，<br><img src="/files/cephfs_object/15.png"><br>任务详情中要给出inode id，file length，data pool这些信息，以便于后台线程推导出对象名下发删除请求；<br>当一个目录被删除后，它的dirfrag对象也要通过这种方式清理，<br>任务详情要改一下，把file length换成分片数，data pool换成metadata pool；<br><img src="/files/cephfs_object/16.png"><br>purge_queue的地址空间也是不断递增的，但是它没有对象数量的限制，<br>仅当清理任务完成后，才会把对应purge_queue对象移除掉，<br>所以平时没有删除文件的动作时，我们能只能看到后缀为0000的purge_queue对象</p>
<h1 id="file对象"><a href="#file对象" class="headerlink" title="file对象"></a>file对象</h1><p>前面所述对象都是放在元数据池的，但是file对象是放在数据池的；<br>file对象顾名思义就是保存文件内容的，它的分割方法和日志文件如出一辙，这里就不重复介绍了；<br>日志文件舍弃了0-4M的地址空间，从4M后开始写入有效内容，<br>而普通文件则会正常使用0-4M的地址空间，从地址为0处开始写入有效内容；<br>对于inode_id&#x3D;&#x3D;1006的16M文件来说，它的file对象有1006.0000，1006.0001，1006.0002，1006.0003；<br>后缀为0000的对象，相比于其他后缀的file对象并无特殊含义；<br>普通文件不允许出现空洞，file对象必须从0000开始连续出现，<br>如果对应地址范围没有找到对象，则认为文件终止，即使后面存在file对象也不会读取；<br><img src="/files/cephfs_object/17.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/cephfs_object/" data-id="clxt3hctm0006vieqed5ee2fp" data-title="cephfs存储格式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/mdlog" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/mdlog/" class="article-date">
  <time class="dt-published" datetime="2024-05-06T13:56:05.364Z" itemprop="datePublished">2024-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/mdlog/">cephfs元数据日志</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>cephfs为每个active mds准备了各自的元数据日志来确保分布式事务的原子性。单个请求可能涉及多项元数据的更新，而这些元数据可能分布在不同位置，难以确保同步更新。而借助元数据日志，可以先将多项元数据的修改合并成一个日志条目(LogEvent)进行持久化，确保原子性，再尝试将这些修改刷写到各个元数据上，即使个别元数据刷写失败了，也能通过回放日志(replay)的方式，多次重试直到所有元数据达成最终一致状态。</p>
<p>为此在使用元数据日志时需要做出如下约束：</p>
<ol>
<li>不能在写完日志前应答客户端（启用了early_reply的场景除外）。</li>
<li>多mds协作时，各mds只能从元数据池读取自己的元数据，不能读取其他mds负责的元数据。</li>
</ol>
<p>第一点很好理解，如果在应答客户端后，写完日志前，mds发生崩溃，客户端和新接任的mds对于同一个请求的完成状态就无法达成共识。</p>
<p>第二点则是为了避免在元数据同步刷新前，其他mds从数据池读取到了过期的元数据，造成同一个元数据在不同mds上出现分歧的情况。不同mds无法相互读取彼此的日志，而唯有将日志和元数据池内容结合在一起，才能得到最新版本的元数据，因此当一个mds需要读取其他mds负责的元数据的最新内容时，它只能向目标mds发起请求获取，而无法绕过目标mds。</p>
<p>日志文件会被拆分成多个对象存储在元数据池中，这些对象的命名很有规律，比如rank 0 的日志文件的对象范围为200.00000000-200.ffffffff，rank 1的日志文件的对象范围为201.00000000-201.ffffffff，rank 2的日志文件的对象范围为203.00000000-203.ffffffff，依次类推。日志文件的内容如下：<br><img src="/files/mdlog/4.png"></p>
<p>日志的基本属性记录在第一个对象中，包括file_layout、write_pos、expire_pos和trimmed_pos。write_pos代表下一条日志项要写入的位置，也等效于当前的日志长度；expire_pos代表日志重放的起始位置，在这个位置前面的内容都是过期的；trimmed_pos代表上一次裁剪的截止位置，在这个位置之前的对象都被删除了（首对象除外）。从大小关系来说，write_pos &gt; expire_pos &gt;&#x3D; trimmed_pos。</p>
<p>那些已写入日志，但是未同步更新到池中的元数据，会被标记为dirty状态；已经同步更新到池中的元数据会被标记为clean状态。mds清理缓存时只会淘汰那些clean状态的元数据，而忽略dirty状态的元数据。dirty元数据的刷写是一个延迟执行的操作，只有当日志文件保存的内容过多，触发日志裁剪时（MDLog::trim）才会执行。</p>
<p>LogSegment是一个内存结构，用于对LogEvent进行分组，记录每一批LogEvent对应的日志范围，以及相关dirty元数据有哪些。LogSegment既是dirty元数据的刷写单位，也是日志裁剪单位。日志文件不会实际存储任何LogSegment结构，但是会用一个ESubtreeMap类型的LogEvent标志它的开始（防止日志裁剪后丢失SubtreeMap），每2个ESubtreeMap之间的部分就可以视为一个LogSegment。每当累计写入一定数量的LogEvent（mds_log_events_per_segment，默认为1024），或是写满一个对象组后（object_size * stripe_count），就会新建一个LogSegment，管理新写入的LogEvent。</p>
<p>这里有两个参数，可用于限制日志文件的大小。一个是mds_log_max_segments（128），表示LogSegment数量上限；另一个是mds_log_max_events，表示日志文件中的LogEvent数量上限。这两个条件只要有一个超标就会触发日志裁剪。注意，这里的mds_log_max_events必须比mds_log_events_per_segment设置得还大。</p>
<p>达到裁剪条件后，mds就会选取最早的一批LogSegment，将它们对应的dirty元数据刷写到池中。这些LogSegment数量不超过当前数量的三分之一，以控制日志裁剪速度，降低对业务的影响。LogSegment刷写完成后，mds就会更新日志首对象，将expire_pos调整到下一个未被淘汰的LogSegment处。此时，如果[trimmed_pos, expire_pos]这段范围覆盖了完整的对象组，那么mds就会以对象组为单位删除这段范围的日志对象，并调整trimmed_pos到下一个未被删除的位置，不足一个对象组的部分继续保留。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/mdlog/" data-id="clxt3hctn0007vieq8m7h5e3b" data-title="cephfs元数据日志" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/cephfs" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/cephfs/" class="article-date">
  <time class="dt-published" datetime="2024-05-06T12:39:16.472Z" itemprop="datePublished">2024-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/cephfs/">cephfs概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>cephfs是一个分布式文件系统，每个cephfs挂载节点都视为一个client。为了确保各个client间的访问不冲突，cephfs设立了专门的mds进程用来管理文件系统元数据。<br>创建一个cephfs时需要提供两种pool用作存储：一种是元数据池（metadata pool，仅限副本策略），提供给mds保存文件系统的元数据；另一种是数据池（data pool，副本或是纠删策略都行），用于保存纯粹的文件内容。<br>client要针对元数据进行修改时（如create、unlink、rename、setattr等），需要发送请求给mds代为修改，不能直接操作元数据池。<br>client能直接读写数据池，但是也需要从mds得到授权后才能进行。<br>另一方面，mds是能够读写数据池的，比如将文件的backtrace保存在数据池中，或者扫描数据池对象来找回文件大小。<br><img src="/files/cephfs/2.1.png"></p>
<h1 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h1><p>一个文件系统中可以配置多个mds，但并非每个mds都会参与到工作中，文件系统中的rank数决定了会有多少个mds参与工作。一个rank就是一个工位，一个mds就对应一个工人。初始情况下，文件系统中只有一个rank，当用户配置了多个mds时，只会有一个mds被mon选拔为工作者，其余的mds都处于闲置状态（standby），等待故障接管。rank数的修改，是通过调整文件系统的max_mds参数实现的。</p>
<p>当文件系统现有的rank数少于max_mds时，如果存在standby mds，则mon会为其新增rank，让这些standby mds进行接管，新增的rank数取决于当前的standby mds有多少，可能会出现“新增rank后总的rank数还是少于max_mds”的情况；如果不存在standby mds，则rank数不会改变。当文件系统的rank数多于max_mds时，则mon会从最后一个rank开始（id最大），命令相应的mds将缓存的元数据迁移到前面的mds上，然后移除这个rank，并将该mds变回standby状态。</p>
<p>从可用状态来看，rank具有三种类型：up，failed，damaged。up是指那些已被mds接管，能够正常运作的rank；failed是指那些还没有被mds接管，无法运作的rank；damaged是指那些因为元数据异常，而禁止接管的rank。failed和damaged状态的不同之处在于，当存在standby mds时，failed rank能够被接管变为up rank，但是damaged rank则不行，只能在人工修复错误后，通过“ceph mds repaired <rank>”指令来解除该状态。</rank></p>
<p>从是否启用的角度来看，rank具有两种类型：in和stopped。in rank表示那些被文件系统启用，分配了工作职责的rank；stopped rank表示那些已被停用，不再参与文件系统工作的rank。前面提及的文件系统的rank数，准确地来说应是in rank的数量；被停用的rank不会被删除，而是标记为stopped，等待随时启用。由于每次创建新的rank时，都需要将一些与rank相关的信息写入元数据池，采用改为启用&#x2F;停用的方式，能够免去重新创建这些信息，有助于更快地调整可用rank的数量。</p>
<h1 id="文件布局（file-layout）"><a href="#文件布局（file-layout）" class="headerlink" title="文件布局（file_layout）"></a>文件布局（file_layout）</h1><p>文件布局描述的是如何将一段文件内容拆分成多个对象进行存储。在上层应用看来，它们读写的都是一段连续的文件内容。但是实际上，写文件时会将内容拆分存储到多个对象上，读文件时会将对象内容拼凑起来再反馈给上层。<br><img src="/files/cephfs/1.png"><br>文件布局的几个重要属性如下：<br>1.stripe_unit：一个条带单元的长度<br>2.stripe_count：一个条带中的单元数<br>3.object_size：一个对象的长度<br>写文件前，先准备stripe_count个对象，每个对象的大小为object_size，然后将对象划分为多个stripe_unit；写文件时，先写满第一个对象的一个条带单元后，再继续写下一个对象的一个条带单元，直至写满一个条带；接着又回到第一个对象上，开始写它的第二个条带单元，其他对象也是同理，写对等位置上的条带单元。当一组对象都写满后，再换下一组对象继续写。读文件的过程不再累述，就是把一组对象读出来，按照相同的规则拼凑读取即可。</p>
<p>下图中，一个方格就是一个条带单元，一行方格就是一个条带，从名字可以看出条带单元所属的共同对象。<br><img src="/files/cephfs/2.png"><br>默认的文件布局为：stripe_count &#x3D;&#x3D; 1，stripe_unit &#x3D;&#x3D; object_size。此时相当于不对内容进行条带化，而是直接顺序存储到对象上。<br><img src="/files/cephfs/3.png"><br>不同的文件可以采用不同的布局。</p>
<h1 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h1><p><a target="_blank" rel="noopener" href="http://206.237.11.110:4000/2024/05/07/cephfs_object/">存储格式</a></p>
<h1 id="元数据日志"><a href="#元数据日志" class="headerlink" title="元数据日志"></a>元数据日志</h1><p><a target="_blank" rel="noopener" href="http://206.237.11.110:4000/2024/05/06/mdlog/">元数据日志</a></p>
<h1 id="元数据缓存"><a href="#元数据缓存" class="headerlink" title="元数据缓存"></a>元数据缓存</h1><p><a target="_blank" rel="noopener" href="http://206.237.11.110:4000/2024/05/08/cephfs_mdcache/">元数据缓存</a></p>
<h1 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h1><p>为了确保多个client以及多个mds之间的缓存强一致性，cephfs使用分布式锁来控制当前缓存中的元数据的可操作状态。</p>
<p>不同的元数据都有着各自的分布式锁，分布式锁并不对客户端展示，客户端只能看到元数据当前的授权状态。但是客户端发起的元数据请求，会驱动分布式锁状态变化，这些状态变化又会导致不同进程上的授权变更，从而保证不同进程有序地读写相同元数据，避免分歧。</p>
<p>锁状态可以分为稳定状态和过渡状态。仅当锁处于稳定状态后，才能开始处理相应的元数据请求；每两个稳定状态之间都有着特定的过渡状态，需要进行状态迁移时，先转变为过渡状态（避免饥饿现象），确保切换条件满足后，才进入目标态。</p>
<p>几个常用的稳定状态如下：</p>
<ol>
<li>sync状态：这个状态下，目标元数据是共享的、只读的，它在所有进程缓存中都是相同的，任何进程可以基于自己的缓存获得最新的内容。</li>
<li>lock状态：这个状态下，目标元数据被主mds所独占，只能由主mds读写它，client和其他mds无法读取和缓存这个元数据</li>
<li>xlock状态：这个状态下，目标元数据被主mds独占，它比lock状态更严格，只能允许一个特定请求（锁的持有者）读写目标元数据，针对目标元数据的其他请求会被阻塞。</li>
<li>excl状态：这个状态下，目标元数据被特定client独占，只有这个client能够操作目标元数据，其他client和mds（包括主mds）都无法操作。以往client需要修改元数据时，需要先向主mds请求，得到应答后再作用于本地，现在有了特权后，可以直接先在本地修改，把流程走下去，最后再将所有改动合并成一个请求发送给mds进行更新，极大地提升了效率。</li>
</ol>
<p>上述状态的划分只是一个粗略的表述，在不同类型的锁上这些状态的表现效果会略有差异。</p>
<p>cephfs的分布式锁流程十分复杂，这里只能提供一个粗略的示意图：<br><img src="/files/cephfs/22.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/cephfs/" data-id="clxt3hcta0004vieqct2tcqz2" data-title="cephfs概述" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/bluestore" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/bluestore/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T15:13:06.769Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/bluestore/">Bluestore存储结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="物理段"><a href="#物理段" class="headerlink" title="物理段"></a>物理段</h2><p>物理段对应磁盘上的一段连续区域，使用“物理偏移量 + 长度”组成的二元组来表示它。物理段的偏移量和长度都是块大小对齐的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct bluestore_pextent_t: public bluestore_interval_t&lt;uint64_t, uint32_t&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p>由于磁盘分配器不一定能够分配出大段连续的物理区域，所以我们需要抽象出一个Blob结构，用于将申请到的多个不连续物理段映射为一个连续的逻辑区域。一个blob对应一个bluestore_blob_t结构体，它的基本属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct bluestore_blob_t &#123;</span><br><span class="line">    PExtentVector extents;  // blob包含的物理段</span><br><span class="line">    uint32_t logical_length = 0;       // blob的逻辑长度</span><br><span class="line">    uint32_t compressed_length = 0;   // blob压缩后的长度</span><br><span class="line">    uint32_t flags = 0;  // 描述blob的一些额外特征</span><br><span class="line">    uint16_t  unused = 0; // 用一个位图来表示blob各个部分的使用情况</span><br><span class="line">    uint8_t csum_type = Checksummer::CSUM_NONE;    // 校验算法，如CRC32</span><br><span class="line">    uint8_t csum_chunk_order = 0;   // 校验块长度 =  1&lt;&lt;block_order bytes</span><br><span class="line">    bufferptr csum_data;     // 用于保存校验码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于extents列表我们可以很容易推算出blob的每个逻辑部分对应的磁盘区域。<br>unused位图用于在写事务中，判断目标区域是否存在数据。如果没有数据，写事务可以直接覆写目标区域，否则需要先读取旧数据和当前数据合并后再写入。unused位图只有16位，意味着它最多将blob均匀划分成16份来统计各部分的使用情况，当blob的长度发生变化时，每个位代表的区域长度也会随之变化。<br>blob的校验码计算，是将blob按照csum_chunk_order表示的大小拆分成多个等长的块，分别计算出校验码后，再按顺序连接起来保存到csum_data中。</p>
<p>flags的可选值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEGACY_FLAG_MUTABLE = 1,  // 表示blob可以被覆写和拆分</span><br><span class="line">FLAG_COMPRESSED = 2,   // blob已经被压缩了，不可修改</span><br><span class="line">FLAG_CSUM = 4,         // blob已经计算出校验码了</span><br><span class="line">FLAG_HAS_UNUSED = 8,   // blob包含未被使用的部分</span><br><span class="line">FLAG_SHARED = 16,      // blob被多个对象所共享，不可修改</span><br></pre></td></tr></table></figure>
<p>其中LEGACY_FLAG_MUTABLE是个废弃的标志，它等价于（flags &amp;（FLAG_COMPRESSED | FLAG_SHARED））&#x3D;&#x3D; 0</p>
<h2 id="Extent"><a href="#Extent" class="headerlink" title="Extent"></a>Extent</h2><p>Blob只是作为磁盘分配器单次申请的逻辑单位，并不能表示对象的空间映射关系，所以还需要增加一个Extent结构来表示对象的一个逻辑段，记录到blob的映射关系。<br>同时磁盘分配器一次分配的逻辑长度可能会超过实际所需的长度（为了减少磁盘碎片化），使用Extent也能更精确地反映出对象实际使用的部分。<br>Extent的基本属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Extent: public ExtentBase &#123;</span><br><span class="line">    uint32_t logical_offset = 0;</span><br><span class="line">    uint32_t blob_offset = 0;</span><br><span class="line">    uint32_t length = 0;</span><br><span class="line">    BlobRef blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Extent的主要成员有4个，分别表示对象内的逻辑偏移量、相对于blob起始地址的偏移量、区段长度和所属的blob。<br><img src="/files/bluestore/2.png"></p>
<h2 id="ExtentMap"><a href="#ExtentMap" class="headerlink" title="ExtentMap"></a>ExtentMap</h2><p>同一个对象下的所有逻辑区段（Extent）组成一个ExtentMap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ExtentMap &#123;</span><br><span class="line">    typedef boost::intrusive::set&lt;Extent&gt; extent_map_t;</span><br><span class="line">    extent_map_t extent_map;</span><br><span class="line">    blob_map_t spanning_blob_map;</span><br><span class="line">    vector&lt;Shard&gt; shards;</span><br><span class="line">    bufferlist inline_bl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>spanning_blob_map用来记录被多个shard共享的blob，和常规的blob分开保存。<br>inline_bl用来缓存extent_map的编码结果，它的编码形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint32_t blobs_num;</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t   blobid;</span><br><span class="line">    uint64_t   gap;</span><br><span class="line">    uint32_t   Extent::blob_offset</span><br><span class="line">    uint32_t   Extent::length; </span><br><span class="line">    Blob       blob;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t   blobid;</span><br><span class="line">    uint64_t   gap;</span><br><span class="line">    uint32_t   Extent::blob_offset</span><br><span class="line">    uint32_t   Extent::length; </span><br><span class="line">    Blob       blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个字段blobs_num表示编码中含有多少个blob，<br>后面则是每个extent的编码，extent的编码从blobid开始，blobid分为两个部分，高位代表当前extent从属于的blob序号，低位则作为解码标志位，用于省略某些字段，优化编码格式<br>gap表示当前extent相对于前一个extent尾部的间隔，当前extent的logical_offset要结合gap和上一个extent的位置来计算，如果这是第一个extent，那么gap就是这个extent的logical_offset。<br>Blob并不总是编码在每个extent之后，如果多个extent共享一个blob，那么Blob只编码在相关的第一个extent后面（此时blob序号为0），后续的extent通过非零的blob序号来索引到相同的blob上。<br>解码标志位的可选值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLOBID_FLAG_CONTIGUOUS: 表示当前gap为0，省略</span><br><span class="line">BLOBID_FLAG_ZEROOFFSET：表示当前blob_offset为0，省略</span><br><span class="line">BLOBID_FLAG_SAMELENGTH：表示length和前一个extent相同，省略</span><br><span class="line">BLOBID_FLAG_SPANNING：表示当前extent从属的blob位于spanning_blob_map中</span><br></pre></td></tr></table></figure>

<h2 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a>Shard</h2><p>在小块随机写过多的情况下，为了避免extent过多导致extent_map编码臃肿，当extent_map内的extent超过一定数量时，就要将extent均匀分成多个组分别编码保存。这里的一个组就是一个Shard。<br>拆分条件是使用ExtentMap::inline_bl的长度来判断的，当它超过一个阈值后，就会舍弃ExtentMap::inline_bl，转而使用ExtentMap::shards记录分片索引。<br>Shard属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Shard &#123;</span><br><span class="line">    bluestore_onode_t::shard_info *shard_info = nullptr;</span><br><span class="line">    unsigned extents = 0;  ///&lt; count extents in this shard</span><br><span class="line">    bool loaded = false;   ///&lt; true if shard is loaded</span><br><span class="line">    bool dirty = false;    ///&lt; true if shard is dirty and needs reencoding</span><br><span class="line">&#125;;</span><br><span class="line">struct shard_info &#123;</span><br><span class="line">    uint32_t offset = 0;  ///&lt; logical offset for start of shard</span><br><span class="line">    uint32_t bytes = 0;   ///&lt; encoded bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Shard在数据库中的保存形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">prefix: &quot;O&quot;</span><br><span class="line">key: &quot;$&#123;oid编码&#125;&quot; + &quot;$&#123;shard_info::offset&#125;&quot; + &quot;x&quot;</span><br><span class="line">value: &#123;</span><br><span class="line">    uint32_t blobs_num;</span><br><span class="line">    &#123;</span><br><span class="line">        uint64_t   blobid;</span><br><span class="line">        uint64_t   gap;</span><br><span class="line">        uint32_t   Extent::blob_offset</span><br><span class="line">        uint32_t   Extent::length; </span><br><span class="line">        Blob       blob;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        uint64_t   blobid;</span><br><span class="line">        uint64_t   gap;</span><br><span class="line">        uint32_t   Extent::blob_offset</span><br><span class="line">        uint32_t   Extent::length; </span><br><span class="line">        Blob       blob;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见Shard value的编码格式和ExtentMap::inline_bl是一致的。</p>
<h2 id="Onode"><a href="#Onode" class="headerlink" title="Onode"></a>Onode</h2><p>Onode结构体用来记录一个对象的元数据，它的属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Onode &#123;</span><br><span class="line">    ghobject_t oid; // 对象标志符</span><br><span class="line">    string key;     // 数据库索引</span><br><span class="line">    ExtentMap extent_map;</span><br><span class="line">    bluestore_onode_t onode;</span><br><span class="line">&#125;;</span><br><span class="line">struct bluestore_onode_t &#123;</span><br><span class="line">  uint64_t nid;  // 用于索引omap</span><br><span class="line">  uint64_t size = 0;  // 对象大小</span><br><span class="line">  map&lt;string, bufferptr&gt; attrs;  // 对象的拓展属性</span><br><span class="line">  vector&lt;shard_info&gt; extent_map_shards; // 分片索引</span><br><span class="line">&#125;;</span><br><span class="line">struct ghobject_t &#123;</span><br><span class="line">  hobject_t hobj;</span><br><span class="line">  gen_t generation; // 对象版本号</span><br><span class="line">  shard_id_t shard_id; // 纠删分片id，对于副本池对象来说这里是NO_SHARD</span><br><span class="line">&#125;;</span><br><span class="line">struct hobject_t &#123;</span><br><span class="line">    object_t oid;  // 对象名（字符串）</span><br><span class="line">    snapid_t snap;  // 快照id（64位整数） </span><br><span class="line">    string nspace; // 命名空间</span><br><span class="line">    int64_t pool; // 归属池</span><br><span class="line">    uint32_t hash_reverse_bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Onode在数据库中的保存形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prefix: &quot;O&quot;</span><br><span class="line">key: &quot;$&#123;oid编码&#125;&quot; + &quot;o&quot;</span><br><span class="line">value: &#123;</span><br><span class="line">    bluestore_onode_t onode;</span><br><span class="line">    blob_map_t ExtentMap::spanning_blob_map;</span><br><span class="line">    bufferlist ExtentMap::inline_bl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此我们得到了获取对象数据的完整步骤：<br>（1）根据对象名计算出onode key<br>（2）根据onode key从数据库加载onode<br>（3）读取onode的extent_map，根据offset找到数据所在的extent<br>（4）找到extent从属的blob，将offset换算成blob内的相对偏移<br>（5）依据blob的相对偏移，得到数据所在的pextent<br>（6）依据pextent给定的坐标，从磁盘上读取数据<br>如果这个对象做了分片，那么在上述（2）、（3）步之间插入以下几步：<br>（7）读取onode的extent_map.shards，根据offset找到数据所在的shard<br>（8）根据shard offset，计算出shard key<br>（9）根据shard key从数据库加载shard value<br>（10）从shard value解码出extent插入到extent_map中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/bluestore/" data-id="clxt3hct50002vieq0p7p45fk" data-title="Bluestore存储结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-files/samba" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/files/samba/" class="article-date">
  <time class="dt-published" datetime="2024-04-23T13:25:13.000Z" itemprop="datePublished">2024-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/files/samba/">samba</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p>（1）为什么我使用本地用户认证无法挂载cifs共享目录？<br><img src="/files/samba/1.jpg"><br>答：检查一下samba服务端能否ping通自己的节点名，如果不行，在&#x2F;etc&#x2F;hosts文件中把节点名加到127.0.0.1后面，再试试看能否挂载cifs共享目录。这个问题的发生可能和ntlm认证有关</p>
<p>（2）我的samba配置了AD域用户组认证，但是使用这个用户组内的用户登录时却失败了，这是为什么？<br>答：原因在于smb.conf中如果没有显式地指定用户组所在的AD域，那么samba会自动推导这个用户组所在的AD域，这有可能得到一个错误的结果，导致认证失败。<br>只有以下两种情况能够在AD域用户组前面省略域名，写成”@group_name”的形式：</p>
<ol>
<li>smb.conf中”winbind use default domain &#x3D; yes”，并且workgroup和AD域名的简写一致</li>
<li>netbios name 和 AD域名的简写一致<br>其他情况下需要在AD域用户组前面加上域名，写成”@realm_name&#x2F;group_name”的形式</li>
</ol>
<p>以下是AD域用户组组认证代码的调用路径：<br><img src="/files/samba/2.jpg"></p>
<p>在token_contains_name环节，检查到名称的第一个字符是@或&amp;或+，就会把后面的字符串当作组名来对待<br>在lookup_name_smbconf这个环节，它分为以下几个步骤：</p>
<ol>
<li>检查组名是否携带AD域名，如果携带AD域名，那么使用给定的AD域名查询组</li>
<li>如果配置项”winbind use default domain &#x3D; yes”（默认是no），那么使用配置项workgroup作为AD域名查询组</li>
<li>使用配置项”netbios name”作为AD域名查询组</li>
<li>使用常量”Unix Group”作为AD域名查询组</li>
</ol>
<p>如果上述步骤都未找到匹配的组，那么本次AD域用户组认证失败</p>
<p>（3） 为什么我的winbind服务在正常运行，但是使用wbinfo -u 查询域用户时却提示“check_winbind_security: wbcAuthenticateUserEx failed: WBC_ERR_WINBIND_NOT_AVAILABLE”？<br>答：用ldd查看一下wbinfo的依赖库路径是否正确，尤其是libwbclient.so，你的环境上有可能存在多个libwbclient.so，而wbinfo引用了错误的libwbclient.so导致未能成功向winbind发送请求</p>
<p>（4）为什么我在使用“net ads join”添加节点到AD域时，提示“failed to find DC for domain”<br><img src="/files/samba/3.jpg"><br>答：&#x2F;etc&#x2F;resolv.conf没有写AD域服务器ip</p>
<p>（5）为什么我在使用“net ads join”添加节点到AD域时，提示“Cannot contact any KDC for requested realm”<br><img src="/files/samba/4.jpg"><br>答：可能是当前节点和AD域服务器之间跨越了太多网段，而kerberos协议默认使用udp传输，很容易丢包引起认证失败<br>解决方案是修改&#x2F;etc&#x2F;krb5.conf：<br>[libdefaults]<br>udp_preference_limit &#x3D; 1<br>参考链接：<br><a target="_blank" rel="noopener" href="https://community.cloudera.com/t5/Community-Articles/Why-you-should-always-set-udp-preference-limit-to-1-instead/ta-p/336166">https://community.cloudera.com/t5/Community-Articles/Why-you-should-always-set-udp-preference-limit-to-1-instead/ta-p/336166</a></p>
<p>（6）为什么我试图通过AD域认证登录samba目录时，log.smbd打印如下错误：<br><img src="/files/samba/5.jpg"><br>答：可能是winbind服务没有成功启动，检查一下它出了什么问题</p>
<p>（7）为什么我在使用“net ads join”添加节点到AD域时，提示“An invalid parameter was passed to a service or function”<br><img src="/files/samba/6.jpg"><br>答：kerberos认证信息中包含时间校验，因此当前节点和域服务器的时差不能过大，否则会判定为认证失败</p>
<p>（8）为什么节点加域时提示：None of the information to be translated has been translated<br>答：这个其实是指你根据一个netbios name 去查找对应的rid 时，AD域服务器没有找到这项映射<br><img src="/files/samba/7.jpg"><br>从上图可以看到一开始节点试图为自己创建一个账户，但是AD域服务器提示这个用户已存在，然后节点才试图根据名称查找rid<br>这种情况一般是AD域服务器上残留了名称相同的其他账户信息，需要将其清理后，才能使当前节点完成加域流程<br>在Active Directory用户和计算机–&gt;域名–&gt;Computers栏目找到同名记录并删除就行了<br><img src="/files/samba/8.jpg"></p>
<p>（9）为什么我的节点“net ads testjoin”是一开始OK的，后面又提示“Join to domain is not valid: The attempted logon is invalid. This is either due to a bad username or authentication information”<br><img src="/files/samba/9.jpg"><br>答：检查一下是不是有其他节点使用了相同的netbios_name，覆写了AD域服务器上的认证信息，导致当前节点的凭据失效<br>为了验证这个猜想，你可以在AD域服务器上删除这个节点，然后使用wireshark抓包，观察一段时间看看是否有其他节点将其重新注册<br><img src="/files/samba/10.jpg"></p>
<p>（10）为什么我在centos 7上尝试用本地用户登录cifs共享目录，却提示”is write-protected, mounting read-only”（samba server配置了AD域认证）<br>答：<br>因为在旧版代码中，cifs client在收到NTLM_NEGITIATE的应答后（”Session Setup Response, Error: STATUS_MORE_PROCESSING_REQUIRED, NTLMSSP_CHALLENGE”）<br>在mount命令未指定domain的情况下，会从报文中提取出服务端的domain信息，自动填充到下一阶段的NTLMSSP_AUTH请求中，<br>这样一来，samba server会认为client试图以一个域用户的身份去登录，自然就无法找到这个用户，而判定没有登录权限，<br>一个简单的解决办法是，在mount options 中随便指定一个不存在的domain来登录（mount -o domain&#x3D;unknown），这样cifs client 就不会自动填充domain，<br>而samba server检查到这个domain无效就会仍按照本地用户去识别，这样就能以本地用户的身份登录成功了<br>在centos 8中这个问题已经由如下commit修复，它通过增加了一个domainauto选项，来默认禁用domain的自动填充功能<br><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/395664439c4945e4827543e3ca80f7b74e1bf733">Fix default behaviour for empty domains and add domainauto option · torvalds&#x2F;linux@3956644 · GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/files/samba/" data-id="clxt3hctq0009vieq4h3rhbnj" data-title="samba" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/index/">目录</a>
          </li>
        
          <li>
            <a href="/files/ceph_spawn/">ceph spawn</a>
          </li>
        
          <li>
            <a href="/files/references/">好文推荐</a>
          </li>
        
          <li>
            <a href="/files/sst/">rocksdb SST格式</a>
          </li>
        
          <li>
            <a href="/files/cephfs_mdcache/">cephfs元数据缓存</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>